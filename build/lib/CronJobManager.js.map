{
  "version": 3,
  "sources": ["../../src/lib/CronJobManager.ts"],
  "sourcesContent": ["import * as ivm from \"isolated-vm\";\nimport * as cron from \"node-cron\";\n\n/**\n * Constants for cron job status and types\n */\nexport const CRON_JOB_STATUS = {\n\tSUCCESS: \"success\",\n\tERROR: \"error\",\n\tPENDING: \"pending\",\n} as const;\n\nexport const CRON_JOB_TYPE = {\n\tONCE: \"once\",\n\tRECURRING: \"recurring\",\n} as const;\n\nexport const CRON_TARGET_TYPE = {\n\tVALUE: \"value\",\n\tSTATE: \"state\",\n\tEXPRESSION: \"expression\",\n} as const;\n\nexport type CronJobStatusType = (typeof CRON_JOB_STATUS)[keyof typeof CRON_JOB_STATUS];\nexport type CronJobTypeType = (typeof CRON_JOB_TYPE)[keyof typeof CRON_JOB_TYPE];\nexport type CronTargetType = (typeof CRON_TARGET_TYPE)[keyof typeof CRON_TARGET_TYPE];\n\n/**\n * Custom error types for better error handling\n */\nexport const CRON_ERROR_CODE = {\n\tINVALID_CRON: \"INVALID_CRON\",\n\tTARGET_NOT_FOUND: \"TARGET_NOT_FOUND\",\n\tEXECUTION_FAILED: \"EXECUTION_FAILED\",\n\tCONFIG_INVALID: \"CONFIG_INVALID\",\n} as const;\n\nexport type CronErrorCode = (typeof CRON_ERROR_CODE)[keyof typeof CRON_ERROR_CODE];\n\nexport class CronJobError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic readonly jobId: string,\n\t\tpublic readonly code: CronErrorCode,\n\t\tpublic readonly originalError?: Error,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"CronJobError\";\n\t}\n}\n\n/**\n * Configuration validation utilities\n */\nexport class ConfigValidator {\n\t/**\n\t * Validate a cron job configuration\n\t */\n\tstatic validateCronJobConfig(config: any, jobId: string): CronJobConfig {\n\t\tif (!config || typeof config !== \"object\") {\n\t\t\tthrow new CronJobError(\"Configuration must be an object\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\t// Validate cron expression\n\t\tif (!config.cron || typeof config.cron !== \"string\") {\n\t\t\tthrow new CronJobError(\n\t\t\t\t\"Cron expression is required and must be a string\",\n\t\t\t\tjobId,\n\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t);\n\t\t}\n\n\t\tif (!cron.validate(config.cron)) {\n\t\t\tthrow new CronJobError(`Invalid cron expression: ${config.cron}`, jobId, CRON_ERROR_CODE.INVALID_CRON);\n\t\t}\n\n\t\t// Validate targets\n\t\tif (!Array.isArray(config.targets) || config.targets.length === 0) {\n\t\t\tthrow new CronJobError(\"Targets must be a non-empty array\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\tconst validatedTargets: CronTarget[] = config.targets.map((target: any, index: number) => {\n\t\t\tif (!target || typeof target !== \"object\") {\n\t\t\t\tthrow new CronJobError(`Target ${index} must be an object`, jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\tif (!target.id || typeof target.id !== \"string\") {\n\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t`Target ${index} id is required and must be a string`,\n\t\t\t\t\tjobId,\n\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (target.value === undefined) {\n\t\t\t\tthrow new CronJobError(`Target ${index} value is required`, jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\t// Validate type field (optional, defaults to \"value\")\n\t\t\tconst targetType = target.type || CRON_TARGET_TYPE.VALUE;\n\t\t\tif (!Object.values(CRON_TARGET_TYPE).includes(targetType)) {\n\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t`Target ${index} type must be one of: ${Object.values(CRON_TARGET_TYPE).join(\", \")}`,\n\t\t\t\t\tjobId,\n\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Validate value based on type\n\t\t\tif (targetType === CRON_TARGET_TYPE.STATE) {\n\t\t\t\t// State reference must be a string\n\t\t\t\tif (typeof target.value !== \"string\" || !target.value.trim()) {\n\t\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t\t`Target ${index} with type 'state' must have a non-empty string value (state ID)`,\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (targetType === CRON_TARGET_TYPE.VALUE) {\n\t\t\t\t// Direct value - validate type\n\t\t\t\tconst valueType = typeof target.value;\n\t\t\t\tif (![\"string\", \"number\", \"boolean\"].includes(valueType) && target.value !== null) {\n\t\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t\t`Target ${index} with type 'value' must be string, number, boolean, or null`,\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (targetType === CRON_TARGET_TYPE.EXPRESSION) {\n\t\t\t\t// Expression must be a string\n\t\t\t\tif (typeof target.value !== \"string\" || !target.value.trim()) {\n\t\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t\t`Target ${index} with type 'expression' must have a non-empty string value`,\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Basic expression validation\n\t\t\t\tConfigValidator.validateExpression(target.value, jobId, index);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: target.id,\n\t\t\t\ttype: targetType,\n\t\t\t\tvalue: target.value,\n\t\t\t\tdescription: target.description || undefined,\n\t\t\t};\n\t\t});\n\n\t\t// Validate active flag\n\t\tif (typeof config.active !== \"boolean\") {\n\t\t\tthrow new CronJobError(\"Active flag must be a boolean\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\t// Validate type\n\t\tif (!config.type || !Object.values(CRON_JOB_TYPE).includes(config.type)) {\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Type must be one of: ${Object.values(CRON_JOB_TYPE).join(\", \")}`,\n\t\t\t\tjobId,\n\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tcron: config.cron,\n\t\t\ttargets: validatedTargets,\n\t\t\tactive: config.active,\n\t\t\ttype: config.type,\n\t\t};\n\t}\n\n\t/**\n\t * Validate expression syntax and security\n\t */\n\tpublic static validateExpression(expression: string, jobId: string, targetIndex: number): void {\n\t\t// Check for valid state reference syntax\n\t\tconst stateReferences = expression.match(/state\\(['\"][^'\"]+['\"]\\)/g) || [];\n\t\tconst stateReferencesSquare = expression.match(/state\\[['\"][^'\"]+['\"]\\]/g) || [];\n\n\t\t// Validate state IDs\n\t\t[...stateReferences, ...stateReferencesSquare].forEach((ref) => {\n\t\t\tconst match = ref.match(/['\"]([^'\"]+)['\"]/);\n\t\t\tif (match) {\n\t\t\t\tconst stateId = match[1];\n\t\t\t\tif (!stateId || stateId.length < 3) {\n\t\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t\t`Target ${targetIndex} expression contains invalid state reference: ${ref}`,\n\t\t\t\t\t\tjobId,\n\t\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Basic syntax check with isolated-vm (safe compilation test)\n\t\ttry {\n\t\t\tconst isolate = new ivm.Isolate({ memoryLimit: 8 }); // Minimum 8MB required\n\t\t\tisolate.compileScriptSync(`(${expression})`);\n\t\t\tisolate.dispose();\n\t\t} catch (error) {\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Target ${targetIndex} expression has invalid JavaScript syntax: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\tjobId,\n\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * Interface for a cron job target\n */\nexport interface CronTarget {\n\tid: string;\n\ttype?: CronTargetType; // Optional for backward compatibility\n\tvalue: string | number | boolean | null;\n\tdescription?: string;\n}\n\n/**\n * Interface for a cron job configuration\n */\nexport interface CronJobConfig {\n\tcron: string;\n\ttargets: CronTarget[];\n\tactive: boolean;\n\ttype: CronJobTypeType;\n}\n\n/**\n * Interface for a cron job status\n */\nexport interface CronJobStatus {\n\tlastRun?: string;\n\tstatus: CronJobStatusType;\n\tnextRun?: string;\n\terror?: string | null;\n}\n\n/**\n * Interface for adapter methods used by CronJobManager\n */\nexport interface AdapterInterface {\n\tlog: ioBroker.Logger;\n\tconfig: {\n\t\tcronFolder?: string;\n\t\tenableLogging?: boolean;\n\t\tdefaultJobsActive?: boolean;\n\t\tmaxConcurrentJobs?: number;\n\t\tjobTimeout?: number;\n\t};\n\tnamespace: string;\n\tsetState(id: string, state: ioBroker.SettableState): void;\n\tsetStateAsync(id: string, state: ioBroker.SettableState): any;\n\tgetStateAsync(id: string): any;\n\tgetStatesAsync(pattern: string): any;\n\tgetObjectAsync(id: string): any;\n\tsetObjectAsync(id: string, obj: ioBroker.SettableObject): any;\n\tsetObjectNotExistsAsync(id: string, obj: ioBroker.SettableObject): any;\n\tsetForeignStateAsync(id: string, state: ioBroker.SettableState): any;\n}\n\n/**\n * Interface for a registered cron job\n */\ninterface RegisteredCronJob {\n\tid: string;\n\tconfig: CronJobConfig;\n\ttask?: cron.ScheduledTask;\n\tstatus: CronJobStatus;\n}\n\n/**\n * CronJobManager handles all cron job operations\n */\nexport class CronJobManager {\n\tprivate adapter: AdapterInterface;\n\tprivate jobs: Map<string, RegisteredCronJob> = new Map();\n\n\tconstructor(adapter: AdapterInterface) {\n\t\tthis.adapter = adapter;\n\t}\n\n\t/**\n\t * Initialize the cron job manager\n\t */\n\tpublic initialize(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Initializing...\");\n\n\t\t// Perform initial scan for existing jobs\n\t\tthis.checkForJobChanges();\n\n\t\tthis.adapter.log.info(\"CronJobManager: Initialized (event-driven mode)\");\n\t}\n\n\t/**\n\t * Shutdown the cron job manager\n\t */\n\tpublic shutdown(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Shutting down...\");\n\n\t\t// Stop all running jobs\n\t\tfor (const [jobId, job] of this.jobs) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Stopped job ${jobId}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.jobs.clear();\n\t\tthis.adapter.log.info(\"CronJobManager: Shutdown complete\");\n\t}\n\n\t/**\n\t * Add or update a cron job\n\t */\n\tpublic async addOrUpdateJob(jobId: string, config: any): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Adding/updating job ${jobId}`);\n\n\t\t\t// Validate and sanitize configuration\n\t\t\tconst validatedConfig = ConfigValidator.validateCronJobConfig(config, jobId);\n\n\t\t\t// Stop existing job if it exists\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob?.task) {\n\t\t\t\texistingJob.task.stop();\n\t\t\t}\n\n\t\t\t// Create new job\n\t\t\tconst newJob: RegisteredCronJob = {\n\t\t\t\tid: jobId,\n\t\t\t\tconfig: { ...validatedConfig },\n\t\t\t\tstatus: {\n\t\t\t\t\tstatus: CRON_JOB_STATUS.PENDING,\n\t\t\t\t\tnextRun: validatedConfig.active ? this.getNextRunTime(validatedConfig.cron) : undefined,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create and start cron task if active\n\t\t\tif (validatedConfig.active) {\n\t\t\t\tnewJob.task = cron.schedule(validatedConfig.cron, () => {\n\t\t\t\t\tthis.executeJob(jobId);\n\t\t\t\t});\n\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Started job ${jobId} with cron '${validatedConfig.cron}'`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} created but not active`);\n\t\t\t}\n\n\t\t\t// Register job\n\t\t\tthis.jobs.set(jobId, newJob);\n\n\t\t\t// Create trigger object if it doesn't exist\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(triggerId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Manual Trigger\",\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\tread: false,\n\t\t\t\t\twrite: true,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Update job status in state\n\t\t\tawait this.updateJobStatus(jobId, newJob.status);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error adding job ${jobId}: ${error}`);\n\n\t\t\t// Update error status\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t};\n\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a cron job\n\t */\n\tpublic removeJob(jobId: string): void {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (job) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t}\n\t\t\tthis.jobs.delete(jobId);\n\t\t\tthis.adapter.log.info(`CronJobManager: Removed job ${jobId}`);\n\t\t}\n\t}\n\n\t/**\n\t * Handle job state change (called from adapter onStateChange)\n\t */\n\tpublic async handleJobStateChange(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Handling state change for job ${jobId}`);\n\n\t\t\t// Get current state and object\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\n\t\t\tif (!state || !obj) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: State or object not found for job ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet config: CronJobConfig;\n\n\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from state value for job ${jobId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error parsing job config from state ${jobId}: ${error}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from native object for job ${jobId}`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (!existingJob || JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tif (existingJob) {\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Configuration changed for job ${jobId}, removing old job`);\n\t\t\t\t\tthis.removeJob(jobId);\n\t\t\t\t}\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Adding job ${jobId} with new configuration`);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error handling state change for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a job\n\t */\n\tpublic async triggerJob(jobId: string): Promise<void> {\n\t\t// Before triggering, ensure we have the latest configuration\n\t\tawait this.refreshJobConfig(jobId);\n\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t}\n\n\t\tthis.adapter.log.info(`CronJobManager: Manually triggering job ${jobId}`);\n\t\tawait this.executeJob(jobId);\n\t}\n\n\t/**\n\t * Refresh job configuration from current state\n\t */\n\tprivate async refreshJobConfig(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state value\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\n\t\t\tif (!state || !obj) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: Could not refresh config for job ${jobId} - state or object not found`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet config: CronJobConfig;\n\n\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from state value for job ${jobId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error parsing job config from state ${jobId}: ${error}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from native object for job ${jobId}`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId} during refresh`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate config\n\t\t\tif (!config.cron || !config.targets) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`CronJobManager: Invalid refreshed config for job ${jobId}: missing cron or targets`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob && JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Config changed during refresh for job ${jobId}, updating job`);\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tthis.removeJob(jobId);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error refreshing job config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a cron job\n\t */\n\tprivate async executeJob(jobId: string): Promise<void> {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Job ${jobId} not found for execution`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = new Date().toISOString();\n\t\tthis.adapter.log.info(`CronJobManager: Executing job ${jobId}`);\n\n\t\ttry {\n\t\t\t// Execute all targets\n\t\t\tthis.adapter.log.debug(`CronJobManager: Job ${jobId} has ${job.config.targets.length} targets to execute`);\n\t\t\tfor (const target of job.config.targets) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Executing target ${target.id} with value ${target.value}`);\n\t\t\t\tawait this.executeTarget(target);\n\t\t\t}\n\n\t\t\t// Update status\n\t\t\tconst status: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.SUCCESS,\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = status;\n\t\t\tawait this.updateJobStatus(jobId, status);\n\n\t\t\t// Handle once-type jobs\n\t\t\tif (job.config.type === CRON_JOB_TYPE.ONCE) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: One-time job ${jobId} completed, deactivating`);\n\t\t\t\tjob.config.active = false;\n\t\t\t\tif (job.task) {\n\t\t\t\t\tjob.task.stop();\n\t\t\t\t}\n\n\t\t\t\t// Update the job state to inactive\n\t\t\t\tawait this.updateJobConfig(jobId, job.config);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} executed successfully`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error executing job ${jobId}: ${error}`);\n\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = errorStatus;\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a single target\n\t */\n\tprivate async executeTarget(target: CronTarget): Promise<void> {\n\t\ttry {\n\t\t\t// Resolve the target value based on type\n\t\t\tconst resolvedValue = await this.resolveTargetValue(target);\n\n\t\t\t// Set the state with proper acknowledgment\n\t\t\tawait this.adapter.setForeignStateAsync(target.id, {\n\t\t\t\tval: resolvedValue,\n\t\t\t\tack: false,\n\t\t\t});\n\t\t\tthis.adapter.log.debug(\n\t\t\t\t`CronJobManager: Set ${target.id} = ${resolvedValue} (type: ${target.type || CRON_TARGET_TYPE.VALUE})`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = `Error setting ${target.id}: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tthis.adapter.log.error(`CronJobManager: ${errorMessage}`);\n\t\t\tthrow new CronJobError(\n\t\t\t\terrorMessage,\n\t\t\t\ttarget.id,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve target value based on type\n\t */\n\tprivate async resolveTargetValue(target: CronTarget): Promise<string | number | boolean | null> {\n\t\tconst targetType = target.type || CRON_TARGET_TYPE.VALUE; // Default to \"value\" for backward compatibility\n\n\t\tswitch (targetType) {\n\t\t\tcase CRON_TARGET_TYPE.VALUE:\n\t\t\t\t// Direct value - return as is\n\t\t\t\treturn target.value;\n\n\t\t\tcase CRON_TARGET_TYPE.STATE:\n\t\t\t\t// State reference - resolve from ioBroker\n\t\t\t\treturn await this.resolveStateReference(target.value as string, target.id);\n\n\t\t\tcase CRON_TARGET_TYPE.EXPRESSION:\n\t\t\t\t// Expression - evaluate JavaScript expression\n\t\t\t\treturn await this.resolveExpression(target.value as string, target.id);\n\n\t\t\tdefault:\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: Unknown target type '${targetType}' for target ${target.id}, using direct value`,\n\t\t\t\t);\n\t\t\t\treturn target.value;\n\t\t}\n\t}\n\n\t/**\n\t * Resolve state reference to actual state value\n\t */\n\tprivate async resolveStateReference(stateId: string, targetId: string): Promise<string | number | boolean | null> {\n\t\ttry {\n\t\t\tif (!stateId || typeof stateId !== \"string\") {\n\t\t\t\tthrow new CronJobError(`Invalid state reference: ${stateId}`, targetId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Resolving state reference '${stateId}' for target ${targetId}`);\n\n\t\t\t// Get the referenced state\n\t\t\tconst state = await this.adapter.getStateAsync(stateId);\n\t\t\tif (!state) {\n\t\t\t\tthrow new CronJobError(`State '${stateId}' not found`, targetId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t\t}\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Resolved state '${stateId}' = ${state.val} for target ${targetId}`);\n\t\t\treturn state.val;\n\t\t} catch (error) {\n\t\t\tif (error instanceof CronJobError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Error resolving state reference '${stateId}': ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\ttargetId,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve JavaScript expression with secure sandbox\n\t */\n\tprivate async resolveExpression(expression: string, targetId: string): Promise<string | number | boolean | null> {\n\t\ttry {\n\t\t\tif (!expression || typeof expression !== \"string\") {\n\t\t\t\tthrow new CronJobError(`Invalid expression: ${expression}`, targetId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Evaluating expression '${expression}' for target ${targetId}`);\n\n\t\t\t// Build context with state references\n\t\t\tconst context = await this.buildExpressionContext(expression, targetId);\n\n\t\t\t// Evaluate expression in sandbox\n\t\t\tconst result = await this.evaluateInSandbox(expression, context, targetId);\n\n\t\t\tthis.adapter.log.debug(\n\t\t\t\t`CronJobManager: Expression '${expression}' evaluated to ${result} for target ${targetId}`,\n\t\t\t);\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (error instanceof CronJobError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Error evaluating expression '${expression}': ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\ttargetId,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Build context for expression evaluation by resolving state references\n\t */\n\tprivate async buildExpressionContext(expression: string, targetId: string): Promise<Record<string, any>> {\n\t\tconst context: Record<string, any> = {};\n\n\t\t// Find state references in expression (pattern: state['id'] or state(\"id\"))\n\t\tconst statePatterns = [\n\t\t\t/state\\(['\"]([^'\"]+)['\"]\\)/g, // state('id') or state(\"id\")\n\t\t\t/state\\[['\"]([^'\"]+)['\"]\\]/g, // state['id'] or state[\"id\"]\n\t\t];\n\n\t\tfor (const pattern of statePatterns) {\n\t\t\tlet match;\n\t\t\twhile ((match = pattern.exec(expression)) !== null) {\n\t\t\t\tconst stateId = match[1];\n\t\t\t\tif (!context[`state_${stateId.replace(/[^a-zA-Z0-9_]/g, \"_\")}`]) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst state = await this.adapter.getStateAsync(stateId);\n\t\t\t\t\t\tconst safeName = `state_${stateId.replace(/[^a-zA-Z0-9_]/g, \"_\")}`;\n\t\t\t\t\t\tcontext[safeName] = state ? state.val : null;\n\t\t\t\t\t\tthis.adapter.log.debug(\n\t\t\t\t\t\t\t`CronJobManager: Added state '${stateId}' = ${context[safeName]} to expression context`,\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t\t\t`CronJobManager: Could not resolve state '${stateId}' for expression: ${error}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontext[`state_${stateId.replace(/[^a-zA-Z0-9_]/g, \"_\")}`] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add current timestamp (isolated-vm has built-in Math and Date objects)\n\t\tcontext.now = Date.now();\n\n\t\treturn context;\n\t}\n\n\t/**\n\t * Evaluate expression in isolated-vm sandbox\n\t */\n\tprivate async evaluateInSandbox(expression: string, context: Record<string, any>, targetId: string): Promise<any> {\n\t\ttry {\n\t\t\t// Replace state references with context variables\n\t\t\tlet processedExpression = expression;\n\n\t\t\t// Replace both state('id') and state['id'] with context variables\n\t\t\tprocessedExpression = processedExpression.replace(\n\t\t\t\t/state\\((['\"])([^'\"]+)\\1\\)|state\\[(['\"])([^'\"]+)\\3\\]/g,\n\t\t\t\t(match, quote1, stateId1, quote2, stateId2) => {\n\t\t\t\t\tconst stateId = stateId1 || stateId2;\n\t\t\t\t\treturn `state_${stateId.replace(/[^a-zA-Z0-9_]/g, \"_\")}`;\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Processed expression: ${processedExpression}`);\n\n\t\t\t// Create isolated VM instance\n\t\t\tconst isolate = new ivm.Isolate({ memoryLimit: 8 }); // 8MB memory limit\n\t\t\tconst ivmContext = await isolate.createContext();\n\t\t\tconst jail = ivmContext.global;\n\n\t\t\t// Set up safe context in isolated VM\n\t\t\tawait jail.set(\"global\", jail.derefInto());\n\n\t\t\t// Add context variables to jail (state values and primitives only)\n\t\t\tfor (const [key, value] of Object.entries(context)) {\n\t\t\t\tif (key !== \"Math\" && key !== \"Date\") {\n\t\t\t\t\t// Only handle primitives (numbers, strings, booleans, null)\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof value === \"number\" ||\n\t\t\t\t\t\ttypeof value === \"string\" ||\n\t\t\t\t\t\ttypeof value === \"boolean\" ||\n\t\t\t\t\t\tvalue === null\n\t\t\t\t\t) {\n\t\t\t\t\t\tawait jail.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Execute expression with timeout\n\t\t\tconst script = await isolate.compileScript(`(${processedExpression})`);\n\t\t\tconst result = await script.run(ivmContext, { timeout: 5000 }); // 5 second timeout\n\n\t\t\t// Clean up\n\t\t\tisolate.dispose();\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Expression sandbox execution failed: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t\ttargetId,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Update job status in ioBroker state\n\t */\n\tprivate async updateJobStatus(jobId: string, status: CronJobStatus): Promise<void> {\n\t\ttry {\n\t\t\t// Create a status state instead of overwriting the job state\n\t\t\tconst statusId = jobId + \".status\";\n\n\t\t\t// Ensure the status object exists\n\t\t\tawait this.adapter.setObjectNotExistsAsync(statusId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Job Status\",\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trole: \"json\",\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Set the status value\n\t\t\tthis.adapter.setState(statusId, {\n\t\t\t\tval: JSON.stringify(status),\n\t\t\t\tack: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating status for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Update job config in ioBroker state\n\t */\n\tprivate async updateJobConfig(jobId: string, config: CronJobConfig): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tif (state) {\n\t\t\t\t// Update the state with new config in common.native\n\t\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.native = config;\n\t\t\t\t\tawait this.adapter.setObjectAsync(jobId, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get next run time for a cron expression\n\t */\n\tprivate getNextRunTime(cronExpression: string): string | undefined {\n\t\ttry {\n\t\t\t// This is a simplified implementation\n\t\t\t// In a real implementation, you'd use a proper cron parser\n\t\t\tconst now = new Date();\n\t\t\tconst nextRun = new Date(now.getTime() + 60000); // Simple: next minute\n\t\t\treturn nextRun.toISOString();\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error calculating next run time: ${error}`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initial scan for existing jobs (called once during initialization)\n\t */\n\tprivate async checkForJobChanges(): Promise<void> {\n\t\ttry {\n\t\t\tconst cronFolder = this.adapter.config.cronFolder || `${this.adapter.namespace}.jobs`;\n\n\t\t\t// Get all states in the cron folder\n\t\t\tconst states = await this.adapter.getStatesAsync(`${cronFolder}.*`);\n\t\t\tif (!states) {\n\t\t\t\tthis.adapter.log.debug(\"CronJobManager: No existing jobs found during initialization\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Found ${Object.keys(states).length} states during initialization`);\n\n\t\t\t// Process each state\n\t\t\tfor (const [stateId, state] of Object.entries(states)) {\n\t\t\t\t// Skip trigger states, status states and non-job states\n\t\t\t\tif (stateId.endsWith(\".trigger\") || stateId.endsWith(\".status\") || !state) continue;\n\n\t\t\t\t// Process this job using the new event-driven method\n\t\t\t\tawait this.handleJobStateChange(stateId);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Initialized ${this.jobs.size} jobs`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error during initial job scan: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get status of all jobs\n\t */\n\tpublic getJobsStatus(): Array<{ id: string; config: CronJobConfig; status: CronJobStatus }> {\n\t\treturn Array.from(this.jobs.values()).map((job) => ({\n\t\t\tid: job.id,\n\t\t\tconfig: job.config,\n\t\t\tstatus: job.status,\n\t\t}));\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAqB;AACrB,WAAsB;AAKf,MAAM,kBAAkB;AAAA,EAC9B,SAAS;AAAA,EACT,OAAO;AAAA,EACP,SAAS;AACV;AAEO,MAAM,gBAAgB;AAAA,EAC5B,MAAM;AAAA,EACN,WAAW;AACZ;AAEO,MAAM,mBAAmB;AAAA,EAC/B,OAAO;AAAA,EACP,OAAO;AAAA,EACP,YAAY;AACb;AASO,MAAM,kBAAkB;AAAA,EAC9B,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,gBAAgB;AACjB;AAIO,MAAM,qBAAqB,MAAM;AAAA,EACvC,YACC,SACgB,OACA,MACA,eACf;AACD,UAAM,OAAO;AAJG;AACA;AACA;AAGhB,SAAK,OAAO;AAAA,EACb;AACD;AAKO,MAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA,EAI5B,OAAO,sBAAsB,QAAa,OAA8B;AACvE,QAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AAC1C,YAAM,IAAI,aAAa,mCAAmC,OAAO,gBAAgB,cAAc;AAAA,IAChG;AAGA,QAAI,CAAC,OAAO,QAAQ,OAAO,OAAO,SAAS,UAAU;AACpD,YAAM,IAAI;AAAA,QACT;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,MACjB;AAAA,IACD;AAEA,QAAI,CAAC,KAAK,SAAS,OAAO,IAAI,GAAG;AAChC,YAAM,IAAI,aAAa,4BAA4B,OAAO,IAAI,IAAI,OAAO,gBAAgB,YAAY;AAAA,IACtG;AAGA,QAAI,CAAC,MAAM,QAAQ,OAAO,OAAO,KAAK,OAAO,QAAQ,WAAW,GAAG;AAClE,YAAM,IAAI,aAAa,qCAAqC,OAAO,gBAAgB,cAAc;AAAA,IAClG;AAEA,UAAM,mBAAiC,OAAO,QAAQ,IAAI,CAAC,QAAa,UAAkB;AACzF,UAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AAC1C,cAAM,IAAI,aAAa,UAAU,KAAK,sBAAsB,OAAO,gBAAgB,cAAc;AAAA,MAClG;AAEA,UAAI,CAAC,OAAO,MAAM,OAAO,OAAO,OAAO,UAAU;AAChD,cAAM,IAAI;AAAA,UACT,UAAU,KAAK;AAAA,UACf;AAAA,UACA,gBAAgB;AAAA,QACjB;AAAA,MACD;AAEA,UAAI,OAAO,UAAU,QAAW;AAC/B,cAAM,IAAI,aAAa,UAAU,KAAK,sBAAsB,OAAO,gBAAgB,cAAc;AAAA,MAClG;AAGA,YAAM,aAAa,OAAO,QAAQ,iBAAiB;AACnD,UAAI,CAAC,OAAO,OAAO,gBAAgB,EAAE,SAAS,UAAU,GAAG;AAC1D,cAAM,IAAI;AAAA,UACT,UAAU,KAAK,yBAAyB,OAAO,OAAO,gBAAgB,EAAE,KAAK,IAAI,CAAC;AAAA,UAClF;AAAA,UACA,gBAAgB;AAAA,QACjB;AAAA,MACD;AAGA,UAAI,eAAe,iBAAiB,OAAO;AAE1C,YAAI,OAAO,OAAO,UAAU,YAAY,CAAC,OAAO,MAAM,KAAK,GAAG;AAC7D,gBAAM,IAAI;AAAA,YACT,UAAU,KAAK;AAAA,YACf;AAAA,YACA,gBAAgB;AAAA,UACjB;AAAA,QACD;AAAA,MACD,WAAW,eAAe,iBAAiB,OAAO;AAEjD,cAAM,YAAY,OAAO,OAAO;AAChC,YAAI,CAAC,CAAC,UAAU,UAAU,SAAS,EAAE,SAAS,SAAS,KAAK,OAAO,UAAU,MAAM;AAClF,gBAAM,IAAI;AAAA,YACT,UAAU,KAAK;AAAA,YACf;AAAA,YACA,gBAAgB;AAAA,UACjB;AAAA,QACD;AAAA,MACD,WAAW,eAAe,iBAAiB,YAAY;AAEtD,YAAI,OAAO,OAAO,UAAU,YAAY,CAAC,OAAO,MAAM,KAAK,GAAG;AAC7D,gBAAM,IAAI;AAAA,YACT,UAAU,KAAK;AAAA,YACf;AAAA,YACA,gBAAgB;AAAA,UACjB;AAAA,QACD;AAGA,wBAAgB,mBAAmB,OAAO,OAAO,OAAO,KAAK;AAAA,MAC9D;AAEA,aAAO;AAAA,QACN,IAAI,OAAO;AAAA,QACX,MAAM;AAAA,QACN,OAAO,OAAO;AAAA,QACd,aAAa,OAAO,eAAe;AAAA,MACpC;AAAA,IACD,CAAC;AAGD,QAAI,OAAO,OAAO,WAAW,WAAW;AACvC,YAAM,IAAI,aAAa,iCAAiC,OAAO,gBAAgB,cAAc;AAAA,IAC9F;AAGA,QAAI,CAAC,OAAO,QAAQ,CAAC,OAAO,OAAO,aAAa,EAAE,SAAS,OAAO,IAAI,GAAG;AACxE,YAAM,IAAI;AAAA,QACT,wBAAwB,OAAO,OAAO,aAAa,EAAE,KAAK,IAAI,CAAC;AAAA,QAC/D;AAAA,QACA,gBAAgB;AAAA,MACjB;AAAA,IACD;AAEA,WAAO;AAAA,MACN,MAAM,OAAO;AAAA,MACb,SAAS;AAAA,MACT,QAAQ,OAAO;AAAA,MACf,MAAM,OAAO;AAAA,IACd;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,mBAAmB,YAAoB,OAAe,aAA2B;AAE9F,UAAM,kBAAkB,WAAW,MAAM,0BAA0B,KAAK,CAAC;AACzE,UAAM,wBAAwB,WAAW,MAAM,0BAA0B,KAAK,CAAC;AAG/E,KAAC,GAAG,iBAAiB,GAAG,qBAAqB,EAAE,QAAQ,CAAC,QAAQ;AAC/D,YAAM,QAAQ,IAAI,MAAM,kBAAkB;AAC1C,UAAI,OAAO;AACV,cAAM,UAAU,MAAM,CAAC;AACvB,YAAI,CAAC,WAAW,QAAQ,SAAS,GAAG;AACnC,gBAAM,IAAI;AAAA,YACT,UAAU,WAAW,iDAAiD,GAAG;AAAA,YACzE;AAAA,YACA,gBAAgB;AAAA,UACjB;AAAA,QACD;AAAA,MACD;AAAA,IACD,CAAC;AAGD,QAAI;AACH,YAAM,UAAU,IAAI,IAAI,QAAQ,EAAE,aAAa,EAAE,CAAC;AAClD,cAAQ,kBAAkB,IAAI,UAAU,GAAG;AAC3C,cAAQ,QAAQ;AAAA,IACjB,SAAS,OAAO;AACf,YAAM,IAAI;AAAA,QACT,UAAU,WAAW,8CAA8C,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACzH;AAAA,QACA,gBAAgB;AAAA,MACjB;AAAA,IACD;AAAA,EACD;AACD;AAoEO,MAAM,eAAe;AAAA,EACnB;AAAA,EACA,OAAuC,oBAAI,IAAI;AAAA,EAEvD,YAAY,SAA2B;AACtC,SAAK,UAAU;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKO,aAAmB;AACzB,SAAK,QAAQ,IAAI,KAAK,iCAAiC;AAGvD,SAAK,mBAAmB;AAExB,SAAK,QAAQ,IAAI,KAAK,iDAAiD;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKO,WAAiB;AACvB,SAAK,QAAQ,IAAI,KAAK,kCAAkC;AAGxD,eAAW,CAAC,OAAO,GAAG,KAAK,KAAK,MAAM;AACrC,UAAI,IAAI,MAAM;AACb,YAAI,KAAK,KAAK;AACd,aAAK,QAAQ,IAAI,MAAM,+BAA+B,KAAK,EAAE;AAAA,MAC9D;AAAA,IACD;AAEA,SAAK,KAAK,MAAM;AAChB,SAAK,QAAQ,IAAI,KAAK,mCAAmC;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,eAAe,OAAe,QAA4B;AACtE,QAAI;AACH,WAAK,QAAQ,IAAI,MAAM,uCAAuC,KAAK,EAAE;AAGrE,YAAM,kBAAkB,gBAAgB,sBAAsB,QAAQ,KAAK;AAG3E,YAAM,cAAc,KAAK,KAAK,IAAI,KAAK;AACvC,UAAI,2CAAa,MAAM;AACtB,oBAAY,KAAK,KAAK;AAAA,MACvB;AAGA,YAAM,SAA4B;AAAA,QACjC,IAAI;AAAA,QACJ,QAAQ,EAAE,GAAG,gBAAgB;AAAA,QAC7B,QAAQ;AAAA,UACP,QAAQ,gBAAgB;AAAA,UACxB,SAAS,gBAAgB,SAAS,KAAK,eAAe,gBAAgB,IAAI,IAAI;AAAA,QAC/E;AAAA,MACD;AAGA,UAAI,gBAAgB,QAAQ;AAC3B,eAAO,OAAO,KAAK,SAAS,gBAAgB,MAAM,MAAM;AACvD,eAAK,WAAW,KAAK;AAAA,QACtB,CAAC;AAED,aAAK,QAAQ,IAAI,KAAK,+BAA+B,KAAK,eAAe,gBAAgB,IAAI,GAAG;AAAA,MACjG,OAAO;AACN,aAAK,QAAQ,IAAI,KAAK,uBAAuB,KAAK,yBAAyB;AAAA,MAC5E;AAGA,WAAK,KAAK,IAAI,OAAO,MAAM;AAG3B,YAAM,YAAY,QAAQ;AAC1B,YAAM,KAAK,QAAQ,wBAAwB,WAAW;AAAA,QACrD,MAAM;AAAA,QACN,QAAQ;AAAA,UACP,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,QACA,QAAQ,CAAC;AAAA,MACV,CAAC;AAGD,YAAM,KAAK,gBAAgB,OAAO,OAAO,MAAM;AAAA,IAChD,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,oCAAoC,KAAK,KAAK,KAAK,EAAE;AAG5E,YAAM,cAA6B;AAAA,QAClC,QAAQ,gBAAgB;AAAA,QACxB,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC7D;AAEA,YAAM,KAAK,gBAAgB,OAAO,WAAW;AAC7C,YAAM;AAAA,IACP;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKO,UAAU,OAAqB;AACrC,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK;AAC/B,QAAI,KAAK;AACR,UAAI,IAAI,MAAM;AACb,YAAI,KAAK,KAAK;AAAA,MACf;AACA,WAAK,KAAK,OAAO,KAAK;AACtB,WAAK,QAAQ,IAAI,KAAK,+BAA+B,KAAK,EAAE;AAAA,IAC7D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,qBAAqB,OAA8B;AAC/D,QAAI;AACH,WAAK,QAAQ,IAAI,MAAM,iDAAiD,KAAK,EAAE;AAG/E,YAAM,QAAQ,MAAM,KAAK,QAAQ,cAAc,KAAK;AACpD,YAAM,MAAM,MAAM,KAAK,QAAQ,eAAe,KAAK;AAEnD,UAAI,CAAC,SAAS,CAAC,KAAK;AACnB,aAAK,QAAQ,IAAI,MAAM,qDAAqD,KAAK,EAAE;AACnF;AAAA,MACD;AAEA,UAAI;AAGJ,UAAK,MAAc,OAAO,OAAQ,MAAc,QAAQ,UAAU;AACjE,YAAI;AACH,mBAAS,KAAK,MAAO,MAAc,GAAG;AACtC,eAAK,QAAQ,IAAI,MAAM,yDAAyD,KAAK,EAAE;AAAA,QACxF,SAAS,OAAO;AACf,eAAK,QAAQ,IAAI,MAAM,uDAAuD,KAAK,KAAK,KAAK,EAAE;AAC/F;AAAA,QACD;AAAA,MACD,WAAW,IAAI,UAAW,IAAI,OAAe,MAAM;AAClD,iBAAS,IAAI;AACb,aAAK,QAAQ,IAAI,MAAM,2DAA2D,KAAK,EAAE;AAAA,MAC1F,OAAO;AACN,aAAK,QAAQ,IAAI,MAAM,iDAAiD,KAAK,EAAE;AAC/E;AAAA,MACD;AAGA,YAAM,cAAc,KAAK,KAAK,IAAI,KAAK;AACvC,UAAI,CAAC,eAAe,KAAK,UAAU,YAAY,MAAM,MAAM,KAAK,UAAU,MAAM,GAAG;AAElF,YAAI,aAAa;AAChB,eAAK,QAAQ,IAAI,KAAK,iDAAiD,KAAK,oBAAoB;AAChG,eAAK,UAAU,KAAK;AAAA,QACrB;AACA,aAAK,QAAQ,IAAI,KAAK,8BAA8B,KAAK,yBAAyB;AAClF,cAAM,KAAK,eAAe,OAAO,MAAM;AAAA,MACxC;AAAA,IACD,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,uDAAuD,KAAK,KAAK,KAAK,EAAE;AAAA,IAChG;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,WAAW,OAA8B;AAErD,UAAM,KAAK,iBAAiB,KAAK;AAEjC,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK;AAC/B,QAAI,CAAC,KAAK;AACT,YAAM,IAAI,aAAa,OAAO,KAAK,cAAc,OAAO,gBAAgB,gBAAgB;AAAA,IACzF;AAEA,SAAK,QAAQ,IAAI,KAAK,2CAA2C,KAAK,EAAE;AACxE,UAAM,KAAK,WAAW,KAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,OAA8B;AAC5D,QAAI;AAEH,YAAM,QAAQ,MAAM,KAAK,QAAQ,cAAc,KAAK;AACpD,YAAM,MAAM,MAAM,KAAK,QAAQ,eAAe,KAAK;AAEnD,UAAI,CAAC,SAAS,CAAC,KAAK;AACnB,aAAK,QAAQ,IAAI;AAAA,UAChB,oDAAoD,KAAK;AAAA,QAC1D;AACA;AAAA,MACD;AAEA,UAAI;AAGJ,UAAK,MAAc,OAAO,OAAQ,MAAc,QAAQ,UAAU;AACjE,YAAI;AACH,mBAAS,KAAK,MAAO,MAAc,GAAG;AACtC,eAAK,QAAQ,IAAI,MAAM,6DAA6D,KAAK,EAAE;AAAA,QAC5F,SAAS,OAAO;AACf,eAAK,QAAQ,IAAI,MAAM,uDAAuD,KAAK,KAAK,KAAK,EAAE;AAC/F;AAAA,QACD;AAAA,MACD,WAAW,IAAI,UAAW,IAAI,OAAe,MAAM;AAClD,iBAAS,IAAI;AACb,aAAK,QAAQ,IAAI,MAAM,+DAA+D,KAAK,EAAE;AAAA,MAC9F,OAAO;AACN,aAAK,QAAQ,IAAI,MAAM,iDAAiD,KAAK,iBAAiB;AAC9F;AAAA,MACD;AAGA,UAAI,CAAC,OAAO,QAAQ,CAAC,OAAO,SAAS;AACpC,aAAK,QAAQ,IAAI;AAAA,UAChB,oDAAoD,KAAK;AAAA,QAC1D;AACA;AAAA,MACD;AAGA,YAAM,cAAc,KAAK,KAAK,IAAI,KAAK;AACvC,UAAI,eAAe,KAAK,UAAU,YAAY,MAAM,MAAM,KAAK,UAAU,MAAM,GAAG;AACjF,aAAK,QAAQ,IAAI,KAAK,yDAAyD,KAAK,gBAAgB;AAEpG,aAAK,UAAU,KAAK;AACpB,cAAM,KAAK,eAAe,OAAO,MAAM;AAAA,MACxC;AAAA,IACD,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,mDAAmD,KAAK,KAAK,KAAK,EAAE;AAAA,IAC5F;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,WAAW,OAA8B;AACtD,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK;AAC/B,QAAI,CAAC,KAAK;AACT,WAAK,QAAQ,IAAI,MAAM,uBAAuB,KAAK,0BAA0B;AAC7E;AAAA,IACD;AAEA,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY;AACzC,SAAK,QAAQ,IAAI,KAAK,iCAAiC,KAAK,EAAE;AAE9D,QAAI;AAEH,WAAK,QAAQ,IAAI,MAAM,uBAAuB,KAAK,QAAQ,IAAI,OAAO,QAAQ,MAAM,qBAAqB;AACzG,iBAAW,UAAU,IAAI,OAAO,SAAS;AACxC,aAAK,QAAQ,IAAI,MAAM,oCAAoC,OAAO,EAAE,eAAe,OAAO,KAAK,EAAE;AACjG,cAAM,KAAK,cAAc,MAAM;AAAA,MAChC;AAGA,YAAM,SAAwB;AAAA,QAC7B,SAAS;AAAA,QACT,QAAQ,gBAAgB;AAAA,QACxB,SACC,IAAI,OAAO,UAAU,IAAI,OAAO,SAAS,cAAc,YACpD,KAAK,eAAe,IAAI,OAAO,IAAI,IACnC;AAAA,MACL;AAEA,UAAI,SAAS;AACb,YAAM,KAAK,gBAAgB,OAAO,MAAM;AAGxC,UAAI,IAAI,OAAO,SAAS,cAAc,MAAM;AAC3C,aAAK,QAAQ,IAAI,KAAK,gCAAgC,KAAK,0BAA0B;AACrF,YAAI,OAAO,SAAS;AACpB,YAAI,IAAI,MAAM;AACb,cAAI,KAAK,KAAK;AAAA,QACf;AAGA,cAAM,KAAK,gBAAgB,OAAO,IAAI,MAAM;AAAA,MAC7C;AAEA,WAAK,QAAQ,IAAI,KAAK,uBAAuB,KAAK,wBAAwB;AAAA,IAC3E,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,uCAAuC,KAAK,KAAK,KAAK,EAAE;AAE/E,YAAM,cAA6B;AAAA,QAClC,SAAS;AAAA,QACT,QAAQ,gBAAgB;AAAA,QACxB,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC5D,SACC,IAAI,OAAO,UAAU,IAAI,OAAO,SAAS,cAAc,YACpD,KAAK,eAAe,IAAI,OAAO,IAAI,IACnC;AAAA,MACL;AAEA,UAAI,SAAS;AACb,YAAM,KAAK,gBAAgB,OAAO,WAAW;AAAA,IAC9C;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAc,QAAmC;AAC9D,QAAI;AAEH,YAAM,gBAAgB,MAAM,KAAK,mBAAmB,MAAM;AAG1D,YAAM,KAAK,QAAQ,qBAAqB,OAAO,IAAI;AAAA,QAClD,KAAK;AAAA,QACL,KAAK;AAAA,MACN,CAAC;AACD,WAAK,QAAQ,IAAI;AAAA,QAChB,uBAAuB,OAAO,EAAE,MAAM,aAAa,WAAW,OAAO,QAAQ,iBAAiB,KAAK;AAAA,MACpG;AAAA,IACD,SAAS,OAAO;AACf,YAAM,eAAe,iBAAiB,OAAO,EAAE,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAC1G,WAAK,QAAQ,IAAI,MAAM,mBAAmB,YAAY,EAAE;AACxD,YAAM,IAAI;AAAA,QACT;AAAA,QACA,OAAO;AAAA,QACP,gBAAgB;AAAA,QAChB,iBAAiB,QAAQ,QAAQ;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,mBAAmB,QAA+D;AAC/F,UAAM,aAAa,OAAO,QAAQ,iBAAiB;AAEnD,YAAQ,YAAY;AAAA,MACnB,KAAK,iBAAiB;AAErB,eAAO,OAAO;AAAA,MAEf,KAAK,iBAAiB;AAErB,eAAO,MAAM,KAAK,sBAAsB,OAAO,OAAiB,OAAO,EAAE;AAAA,MAE1E,KAAK,iBAAiB;AAErB,eAAO,MAAM,KAAK,kBAAkB,OAAO,OAAiB,OAAO,EAAE;AAAA,MAEtE;AACC,aAAK,QAAQ,IAAI;AAAA,UAChB,wCAAwC,UAAU,gBAAgB,OAAO,EAAE;AAAA,QAC5E;AACA,eAAO,OAAO;AAAA,IAChB;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,sBAAsB,SAAiB,UAA6D;AACjH,QAAI;AACH,UAAI,CAAC,WAAW,OAAO,YAAY,UAAU;AAC5C,cAAM,IAAI,aAAa,4BAA4B,OAAO,IAAI,UAAU,gBAAgB,cAAc;AAAA,MACvG;AAEA,WAAK,QAAQ,IAAI,MAAM,8CAA8C,OAAO,gBAAgB,QAAQ,EAAE;AAGtG,YAAM,QAAQ,MAAM,KAAK,QAAQ,cAAc,OAAO;AACtD,UAAI,CAAC,OAAO;AACX,cAAM,IAAI,aAAa,UAAU,OAAO,eAAe,UAAU,gBAAgB,gBAAgB;AAAA,MAClG;AAEA,WAAK,QAAQ,IAAI,MAAM,mCAAmC,OAAO,OAAO,MAAM,GAAG,eAAe,QAAQ,EAAE;AAC1G,aAAO,MAAM;AAAA,IACd,SAAS,OAAO;AACf,UAAI,iBAAiB,cAAc;AAClC,cAAM;AAAA,MACP;AACA,YAAM,IAAI;AAAA,QACT,oCAAoC,OAAO,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACvG;AAAA,QACA,gBAAgB;AAAA,QAChB,iBAAiB,QAAQ,QAAQ;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBAAkB,YAAoB,UAA6D;AAChH,QAAI;AACH,UAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AAClD,cAAM,IAAI,aAAa,uBAAuB,UAAU,IAAI,UAAU,gBAAgB,cAAc;AAAA,MACrG;AAEA,WAAK,QAAQ,IAAI,MAAM,0CAA0C,UAAU,gBAAgB,QAAQ,EAAE;AAGrG,YAAM,UAAU,MAAM,KAAK,uBAAuB,YAAY,QAAQ;AAGtE,YAAM,SAAS,MAAM,KAAK,kBAAkB,YAAY,SAAS,QAAQ;AAEzE,WAAK,QAAQ,IAAI;AAAA,QAChB,+BAA+B,UAAU,kBAAkB,MAAM,eAAe,QAAQ;AAAA,MACzF;AACA,aAAO;AAAA,IACR,SAAS,OAAO;AACf,UAAI,iBAAiB,cAAc;AAClC,cAAM;AAAA,MACP;AACA,YAAM,IAAI;AAAA,QACT,gCAAgC,UAAU,MAAM,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACtG;AAAA,QACA,gBAAgB;AAAA,QAChB,iBAAiB,QAAQ,QAAQ;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBAAuB,YAAoB,UAAgD;AACxG,UAAM,UAA+B,CAAC;AAGtC,UAAM,gBAAgB;AAAA,MACrB;AAAA;AAAA,MACA;AAAA;AAAA,IACD;AAEA,eAAW,WAAW,eAAe;AACpC,UAAI;AACJ,cAAQ,QAAQ,QAAQ,KAAK,UAAU,OAAO,MAAM;AACnD,cAAM,UAAU,MAAM,CAAC;AACvB,YAAI,CAAC,QAAQ,SAAS,QAAQ,QAAQ,kBAAkB,GAAG,CAAC,EAAE,GAAG;AAChE,cAAI;AACH,kBAAM,QAAQ,MAAM,KAAK,QAAQ,cAAc,OAAO;AACtD,kBAAM,WAAW,SAAS,QAAQ,QAAQ,kBAAkB,GAAG,CAAC;AAChE,oBAAQ,QAAQ,IAAI,QAAQ,MAAM,MAAM;AACxC,iBAAK,QAAQ,IAAI;AAAA,cAChB,gCAAgC,OAAO,OAAO,QAAQ,QAAQ,CAAC;AAAA,YAChE;AAAA,UACD,SAAS,OAAO;AACf,iBAAK,QAAQ,IAAI;AAAA,cAChB,4CAA4C,OAAO,qBAAqB,KAAK;AAAA,YAC9E;AACA,oBAAQ,SAAS,QAAQ,QAAQ,kBAAkB,GAAG,CAAC,EAAE,IAAI;AAAA,UAC9D;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAGA,YAAQ,MAAM,KAAK,IAAI;AAEvB,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBAAkB,YAAoB,SAA8B,UAAgC;AACjH,QAAI;AAEH,UAAI,sBAAsB;AAG1B,4BAAsB,oBAAoB;AAAA,QACzC;AAAA,QACA,CAAC,OAAO,QAAQ,UAAU,QAAQ,aAAa;AAC9C,gBAAM,UAAU,YAAY;AAC5B,iBAAO,SAAS,QAAQ,QAAQ,kBAAkB,GAAG,CAAC;AAAA,QACvD;AAAA,MACD;AAEA,WAAK,QAAQ,IAAI,MAAM,yCAAyC,mBAAmB,EAAE;AAGrF,YAAM,UAAU,IAAI,IAAI,QAAQ,EAAE,aAAa,EAAE,CAAC;AAClD,YAAM,aAAa,MAAM,QAAQ,cAAc;AAC/C,YAAM,OAAO,WAAW;AAGxB,YAAM,KAAK,IAAI,UAAU,KAAK,UAAU,CAAC;AAGzC,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AACnD,YAAI,QAAQ,UAAU,QAAQ,QAAQ;AAErC,cACC,OAAO,UAAU,YACjB,OAAO,UAAU,YACjB,OAAO,UAAU,aACjB,UAAU,MACT;AACD,kBAAM,KAAK,IAAI,KAAK,KAAK;AAAA,UAC1B;AAAA,QACD;AAAA,MACD;AAGA,YAAM,SAAS,MAAM,QAAQ,cAAc,IAAI,mBAAmB,GAAG;AACrE,YAAM,SAAS,MAAM,OAAO,IAAI,YAAY,EAAE,SAAS,IAAK,CAAC;AAG7D,cAAQ,QAAQ;AAEhB,aAAO;AAAA,IACR,SAAS,OAAO;AACf,YAAM,IAAI;AAAA,QACT,wCAAwC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QAC9F;AAAA,QACA,gBAAgB;AAAA,QAChB,iBAAiB,QAAQ,QAAQ;AAAA,MAClC;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,OAAe,QAAsC;AAClF,QAAI;AAEH,YAAM,WAAW,QAAQ;AAGzB,YAAM,KAAK,QAAQ,wBAAwB,UAAU;AAAA,QACpD,MAAM;AAAA,QACN,QAAQ;AAAA,UACP,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,QACA,QAAQ,CAAC;AAAA,MACV,CAAC;AAGD,WAAK,QAAQ,SAAS,UAAU;AAAA,QAC/B,KAAK,KAAK,UAAU,MAAM;AAAA,QAC1B,KAAK;AAAA,MACN,CAAC;AAAA,IACF,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,6CAA6C,KAAK,KAAK,KAAK,EAAE;AAAA,IACtF;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,OAAe,QAAsC;AAClF,QAAI;AAEH,YAAM,QAAQ,MAAM,KAAK,QAAQ,cAAc,KAAK;AACpD,UAAI,OAAO;AAEV,cAAM,MAAM,MAAM,KAAK,QAAQ,eAAe,KAAK;AACnD,YAAI,KAAK;AACR,cAAI,SAAS;AACb,gBAAM,KAAK,QAAQ,eAAe,OAAO,GAAG;AAAA,QAC7C;AAAA,MACD;AAAA,IACD,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,6CAA6C,KAAK,KAAK,KAAK,EAAE;AAAA,IACtF;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,gBAA4C;AAClE,QAAI;AAGH,YAAM,MAAM,oBAAI,KAAK;AACrB,YAAM,UAAU,IAAI,KAAK,IAAI,QAAQ,IAAI,GAAK;AAC9C,aAAO,QAAQ,YAAY;AAAA,IAC5B,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,oDAAoD,KAAK,EAAE;AAClF,aAAO;AAAA,IACR;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBAAoC;AACjD,QAAI;AACH,YAAM,aAAa,KAAK,QAAQ,OAAO,cAAc,GAAG,KAAK,QAAQ,SAAS;AAG9E,YAAM,SAAS,MAAM,KAAK,QAAQ,eAAe,GAAG,UAAU,IAAI;AAClE,UAAI,CAAC,QAAQ;AACZ,aAAK,QAAQ,IAAI,MAAM,8DAA8D;AACrF;AAAA,MACD;AAEA,WAAK,QAAQ,IAAI,MAAM,yBAAyB,OAAO,KAAK,MAAM,EAAE,MAAM,+BAA+B;AAGzG,iBAAW,CAAC,SAAS,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAEtD,YAAI,QAAQ,SAAS,UAAU,KAAK,QAAQ,SAAS,SAAS,KAAK,CAAC,MAAO;AAG3E,cAAM,KAAK,qBAAqB,OAAO;AAAA,MACxC;AAEA,WAAK,QAAQ,IAAI,KAAK,+BAA+B,KAAK,KAAK,IAAI,OAAO;AAAA,IAC3E,SAAS,OAAO;AACf,WAAK,QAAQ,IAAI,MAAM,kDAAkD,KAAK,EAAE;AAAA,IACjF;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKO,gBAAqF;AAC3F,WAAO,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC,EAAE,IAAI,CAAC,SAAS;AAAA,MACnD,IAAI,IAAI;AAAA,MACR,QAAQ,IAAI;AAAA,MACZ,QAAQ,IAAI;AAAA,IACb,EAAE;AAAA,EACH;AACD;",
  "names": []
}
