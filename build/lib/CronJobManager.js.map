{
  "version": 3,
  "sources": ["../../src/lib/CronJobManager.ts"],
  "sourcesContent": ["import CronExpressionParser from \"cron-parser\";\nimport * as cron from \"node-cron\";\nimport { ConfigValidator } from \"./ConfigValidator\";\nimport { CRON_JOB_STATUS, CRON_JOB_TYPE, CRON_TARGET_TYPE } from \"./constants\";\nimport { CRON_ERROR_CODE, CronJobError } from \"./errors\";\nimport { AdapterInterface, CronJobConfig, CronJobStatus, CronTarget, RegisteredCronJob } from \"./interfaces\";\n\n// Re-export for backward compatibility\nexport { CRON_ERROR_CODE, CRON_JOB_STATUS, CRON_JOB_TYPE, CRON_TARGET_TYPE, CronJobError };\nexport type { AdapterInterface, CronJobConfig, CronJobStatus, CronTarget, RegisteredCronJob };\n\n/**\n * CronJobManager - Manages cron jobs for the adapter\n */\nexport class CronJobManager {\n\tprivate jobs = new Map<string, RegisteredCronJob>();\n\tprivate cleanupInterval: NodeJS.Timeout | null = null;\n\tprivate triggerStateSubscriptions = new Map<string, string[]>(); // triggerState -> [jobIds]\n\tprivate debounceTimers = new Map<string, NodeJS.Timeout>(); // jobId -> timer\n\n\tconstructor(private adapter: AdapterInterface) {}\n\n\t/**\n\t * Initialize the cron job manager\n\t */\n\tpublic initialize(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Initializing...\");\n\t\tthis.adapter.log.info(\"CronJobManager: Initialized (event-driven mode)\");\n\n\t\t// Start periodic cleanup of orphaned objects\n\t\tthis.startPeriodicCleanup();\n\t}\n\n\t/**\n\t * Shutdown the cron job manager\n\t */\n\tpublic async shutdown(): Promise<void> {\n\t\tthis.adapter.log.info(\"CronJobManager: Shutting down...\");\n\n\t\t// Stop cleanup interval\n\t\tif (this.cleanupInterval) {\n\t\t\tclearInterval(this.cleanupInterval);\n\t\t\tthis.cleanupInterval = null;\n\t\t}\n\n\t\t// Stop all running jobs\n\t\tfor (const [jobId, job] of this.jobs) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Stopped job ${jobId}`);\n\t\t\t}\n\t\t}\n\n\t\t// Clean up all debounce timers\n\t\tfor (const [jobId, timer] of this.debounceTimers) {\n\t\t\tclearTimeout(timer);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up debounce timer for job ${jobId}`);\n\t\t}\n\t\tthis.debounceTimers.clear();\n\n\t\t// Unsubscribe from all trigger states\n\t\tfor (const [triggerState] of this.triggerStateSubscriptions) {\n\t\t\tthis.adapter.unsubscribeStates(triggerState);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Unsubscribed from triggerState ${triggerState}`);\n\t\t}\n\t\tthis.triggerStateSubscriptions.clear();\n\n\t\tthis.jobs.clear();\n\t\tthis.adapter.log.info(\"CronJobManager: Shutdown complete\");\n\t}\n\n\t/**\n\t * Add or update a cron job\n\t */\n\tpublic async addOrUpdateJob(jobId: string, config: any): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Adding/updating job ${jobId}`);\n\n\t\t\t// Validate and sanitize configuration\n\t\t\tconst validatedConfig = ConfigValidator.validateCronJobConfig(config, jobId);\n\n\t\t\t// Stop existing job if it exists\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob?.task) {\n\t\t\t\texistingJob.task.stop();\n\t\t\t}\n\n\t\t\t// Try to preserve existing lastRun from status state\n\t\t\tlet existingLastRun: string | undefined;\n\t\t\ttry {\n\t\t\t\tconst statusId = jobId + \".status\";\n\t\t\t\tconst statusState = await this.adapter.getStateAsync(statusId);\n\t\t\t\tif (statusState?.val) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst existingStatus = JSON.parse(statusState.val as string);\n\t\t\t\t\t\tif (existingStatus.lastRun) {\n\t\t\t\t\t\t\texistingLastRun = existingStatus.lastRun;\n\t\t\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Preserving existing lastRun: ${existingLastRun}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (parseError) {\n\t\t\t\t\t\t// Ignore parse errors, status will be recreated\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Status state doesn't exist yet or can't be read, that's ok\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No existing status found for ${jobId}, creating new`);\n\t\t\t}\n\n\t\t\t// Determine nextRun based on job type and configuration\n\t\t\tlet nextRun: string | undefined;\n\t\t\tif (validatedConfig.active && validatedConfig.type !== CRON_JOB_TYPE.MANUAL && validatedConfig.cron) {\n\t\t\t\t// For ONCE jobs: only set nextRun if not yet executed (no lastRun)\n\t\t\t\tif (validatedConfig.type === CRON_JOB_TYPE.ONCE) {\n\t\t\t\t\tif (!existingLastRun) {\n\t\t\t\t\t\tnextRun = this.getNextRunTime(validatedConfig.cron);\n\t\t\t\t\t}\n\t\t\t\t\t// If lastRun exists, don't set nextRun (job already executed)\n\t\t\t\t} else {\n\t\t\t\t\t// For RECURRING jobs: always set nextRun if active\n\t\t\t\t\tnextRun = this.getNextRunTime(validatedConfig.cron);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create new job\n\t\t\tconst newJob: RegisteredCronJob = {\n\t\t\t\tid: jobId,\n\t\t\t\tconfig: { ...validatedConfig },\n\t\t\t\tstatus: {\n\t\t\t\t\tstatus: CRON_JOB_STATUS.PENDING,\n\t\t\t\t\tlastRun: existingLastRun, // Preserve existing lastRun\n\t\t\t\t\tnextRun: nextRun,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create and start cron task if active and not manual\n\t\t\tif (\n\t\t\t\tvalidatedConfig.active &&\n\t\t\t\tvalidatedConfig.type !== CRON_JOB_TYPE.MANUAL &&\n\t\t\t\tvalidatedConfig.type !== CRON_JOB_TYPE.STATE &&\n\t\t\t\tvalidatedConfig.cron\n\t\t\t) {\n\t\t\t\tnewJob.task = cron.schedule(\n\t\t\t\t\tvalidatedConfig.cron,\n\t\t\t\t\t() => {\n\t\t\t\t\t\tthis.executeJob(jobId);\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttimezone: \"Europe/Berlin\", // Use MEZ/MESZ timezone\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tthis.adapter.log.info(\n\t\t\t\t\t`CronJobManager: Started job ${jobId} with cron '${validatedConfig.cron}' (MEZ/MESZ)`,\n\t\t\t\t);\n\t\t\t} else if (validatedConfig.type === CRON_JOB_TYPE.MANUAL) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Manual job ${jobId} created - trigger only execution`);\n\t\t\t} else if (validatedConfig.type === CRON_JOB_TYPE.STATE) {\n\t\t\t\t// Subscribe to trigger state for STATE jobs\n\t\t\t\tif (validatedConfig.active && validatedConfig.triggerState) {\n\t\t\t\t\tthis.subscribeToTriggerState(validatedConfig.triggerState, jobId);\n\t\t\t\t\tthis.adapter.log.info(\n\t\t\t\t\t\t`CronJobManager: State-triggered job ${jobId} created - monitoring ${validatedConfig.triggerState}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis.adapter.log.info(\n\t\t\t\t\t\t`CronJobManager: State job ${jobId} created but not active or missing triggerState`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} created but not active`);\n\t\t\t}\n\n\t\t\t// Register job\n\t\t\tthis.jobs.set(jobId, newJob);\n\n\t\t\t// Create trigger object if it doesn't exist\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(triggerId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: `Manual trigger for ${jobId}`,\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\tread: false,\n\t\t\t\t\twrite: true,\n\t\t\t\t\tdesc: \"Set to true to manually trigger this job\",\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t\tacl: {\n\t\t\t\t\towner: \"system.user.admin\",\n\t\t\t\t\townerGroup: \"system.group.administrator\",\n\t\t\t\t\tobject: 0x666, // rw-rw-rw- (alle k\u00F6nnen lesen und schreiben)\n\t\t\t\t\tstate: 0x666, // rw-rw-rw- (alle k\u00F6nnen lesen und schreiben)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Create status object if it doesn't exist\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(statusId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: `Status for ${jobId}`,\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trole: \"json\",\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t\tdesc: \"Current status of this job\",\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t\tacl: {\n\t\t\t\t\towner: \"system.user.admin\",\n\t\t\t\t\townerGroup: \"system.group.administrator\",\n\t\t\t\t\tobject: 0x644, // rw-r--r-- (Owner: read+write, alle anderen: read)\n\t\t\t\t\tstate: 0x644, // rw-r--r-- (Owner: read+write, alle anderen: read)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Update status\n\t\t\tawait this.updateJobStatus(jobId, newJob.status);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error adding/updating job ${jobId}: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a cron job and clean up associated objects\n\t */\n\tpublic async removeJob(jobId: string): Promise<void> {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (job) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t}\n\n\t\t\t// Clean up STATE job subscriptions and debounce timers\n\t\t\tif (job.config.type === CRON_JOB_TYPE.STATE && job.config.triggerState) {\n\t\t\t\tthis.unsubscribeFromTriggerState(job.config.triggerState, jobId);\n\t\t\t}\n\n\t\t\t// Clean up debounce timer\n\t\t\tconst debounceTimer = this.debounceTimers.get(jobId);\n\t\t\tif (debounceTimer) {\n\t\t\t\tclearTimeout(debounceTimer);\n\t\t\t\tthis.debounceTimers.delete(jobId);\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up debounce timer for job ${jobId}`);\n\t\t\t}\n\n\t\t\tthis.jobs.delete(jobId);\n\t\t\tthis.adapter.log.info(`CronJobManager: Removed job ${jobId}`);\n\t\t}\n\n\t\t// Clean up associated status and trigger objects\n\t\tawait this.cleanupJobObjects(jobId);\n\t}\n\n\t/**\n\t * Clean up status and trigger objects for a job\n\t */\n\tprivate async cleanupJobObjects(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\t// Remove status object\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.delObjectAsync(statusId);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up status object ${statusId}`);\n\n\t\t\t// Remove trigger object\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.delObjectAsync(triggerId);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up trigger object ${triggerId}`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.warn(`CronJobManager: Error cleaning up objects for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get all registered jobs\n\t */\n\tpublic getJobs(): Map<string, RegisteredCronJob> {\n\t\treturn new Map(this.jobs);\n\t}\n\n\t/**\n\t * Subscribe to a trigger state for a job\n\t */\n\tprivate subscribeToTriggerState(triggerState: string, jobId: string): void {\n\t\tconst existingJobs = this.triggerStateSubscriptions.get(triggerState) || [];\n\n\t\t// Add jobId if not already present\n\t\tif (!existingJobs.includes(jobId)) {\n\t\t\texistingJobs.push(jobId);\n\t\t\tthis.triggerStateSubscriptions.set(triggerState, existingJobs);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Added job ${jobId} to triggerState ${triggerState}`);\n\t\t}\n\n\t\t// Subscribe to state if this is the first job using this triggerState\n\t\tif (existingJobs.length === 1) {\n\t\t\tthis.adapter.subscribeStates(triggerState);\n\t\t\tthis.adapter.log.info(`CronJobManager: Subscribed to triggerState ${triggerState}`);\n\t\t}\n\t}\n\n\t/**\n\t * Unsubscribe from a trigger state for a job\n\t */\n\tprivate unsubscribeFromTriggerState(triggerState: string, jobId: string): void {\n\t\tconst existingJobs = this.triggerStateSubscriptions.get(triggerState);\n\n\t\tif (!existingJobs) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove jobId from list\n\t\tconst updatedJobs = existingJobs.filter((id) => id !== jobId);\n\n\t\tif (updatedJobs.length === 0) {\n\t\t\t// No more jobs using this triggerState - unsubscribe\n\t\t\tthis.triggerStateSubscriptions.delete(triggerState);\n\t\t\tthis.adapter.unsubscribeStates(triggerState);\n\t\t\tthis.adapter.log.info(`CronJobManager: Unsubscribed from triggerState ${triggerState}`);\n\t\t} else {\n\t\t\t// Update list with remaining jobs\n\t\t\tthis.triggerStateSubscriptions.set(triggerState, updatedJobs);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Removed job ${jobId} from triggerState ${triggerState}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get all job IDs that are triggered by a specific state\n\t */\n\tpublic getJobsForTriggerState(triggerState: string): string[] | undefined {\n\t\treturn this.triggerStateSubscriptions.get(triggerState);\n\t}\n\n\t/**\n\t * Check if a state change should trigger a job\n\t */\n\tprivate shouldTrigger(config: CronJobConfig, state: ioBroker.State): boolean {\n\t\t// If triggerValue is set, only trigger when state value matches\n\t\tif (config.triggerValue !== undefined) {\n\t\t\treturn state.val === config.triggerValue;\n\t\t}\n\n\t\t// If triggerOnChange is false, don't trigger (shouldn't happen if triggerValue not set, but check anyway)\n\t\tif (config.triggerOnChange === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Default: trigger on any change\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check and trigger a state job with debouncing\n\t */\n\tpublic checkAndTriggerStateJob(jobId: string, state: ioBroker.State): void {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthis.adapter.log.warn(`CronJobManager: Job ${jobId} not found for state trigger`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if job is active\n\t\tif (!job.config.active) {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Job ${jobId} is not active, skipping trigger`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if this state change should trigger the job\n\t\tif (!this.shouldTrigger(job.config, state)) {\n\t\t\tthis.adapter.log.debug(`CronJobManager: State change for ${jobId} does not match trigger conditions`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Apply debouncing\n\t\tconst debounceDelay = job.config.debounce || 100; // Default 100ms\n\n\t\t// Clear existing timer if present\n\t\tconst existingTimer = this.debounceTimers.get(jobId);\n\t\tif (existingTimer) {\n\t\t\tclearTimeout(existingTimer);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleared existing debounce timer for job ${jobId}`);\n\t\t}\n\n\t\t// Create new timer\n\t\tconst timer = setTimeout(() => {\n\t\t\tthis.debounceTimers.delete(jobId);\n\t\t\tthis.executeJob(jobId).catch((error) => {\n\t\t\t\tthis.adapter.log.error(`CronJobManager: Error executing state-triggered job ${jobId}: ${error}`);\n\t\t\t});\n\t\t}, debounceDelay);\n\n\t\tthis.debounceTimers.set(jobId, timer);\n\t\tthis.adapter.log.debug(\n\t\t\t`CronJobManager: Scheduled state-triggered job ${jobId} with ${debounceDelay}ms debounce`,\n\t\t);\n\t}\n\n\t/**\n\t * Handle state changes for job configurations\n\t */\n\tpublic async handleJobStateChange(jobId: string, state: any): Promise<void> {\n\t\ttry {\n\t\t\tif (!state || !state.val) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Ignoring empty state change for ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Parse configuration\n\t\t\tlet config: any;\n\t\t\ttry {\n\t\t\t\tconfig = JSON.parse(state.val);\n\t\t\t} catch (parseError) {\n\t\t\t\tthis.adapter.log.error(`CronJobManager: Invalid JSON configuration for job ${jobId}: ${parseError}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (!existingJob || JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\t// Stop existing job but keep status/trigger objects when updating\n\t\t\t\tif (existingJob) {\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Configuration changed for job ${jobId}, stopping old job`);\n\t\t\t\t\tif (existingJob.task) {\n\t\t\t\t\t\texistingJob.task.stop();\n\t\t\t\t\t}\n\t\t\t\t\tthis.jobs.delete(jobId);\n\t\t\t\t}\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Adding job ${jobId} with new configuration`);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error handling state change for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a job\n\t */\n\tpublic async triggerJob(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.info(`CronJobManager: Manual trigger requested for job ${jobId}`);\n\n\t\t\t// First, refresh the job configuration to ensure we have the latest version\n\t\t\tawait this.refreshJobConfig(jobId);\n\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tif (!job) {\n\t\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t\t}\n\n\t\t\tif (!job.config.active) {\n\t\t\t\tthis.adapter.log.warn(`CronJobManager: Job ${jobId} is not active, skipping manual trigger`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.executeJob(jobId);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error triggering job ${jobId}: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Refresh job configuration from state\n\t */\n\tprivate async refreshJobConfig(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tconst stateObj = await this.adapter.getStateAsync(jobId);\n\t\t\tif (!stateObj || !stateObj.val) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: No configuration found for job ${jobId} during refresh, keeping existing config`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Parse configuration\n\t\t\tlet config: any;\n\t\t\ttry {\n\t\t\t\tconfig = JSON.parse(stateObj.val as string);\n\t\t\t} catch (parseError) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`CronJobManager: Invalid JSON configuration for job ${jobId} during refresh: ${parseError}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob && JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Config changed during refresh for job ${jobId}, updating job`);\n\t\t\t\t// Stop existing job but keep status/trigger objects when updating\n\t\t\t\tif (existingJob.task) {\n\t\t\t\t\texistingJob.task.stop();\n\t\t\t\t}\n\t\t\t\tthis.jobs.delete(jobId);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error refreshing job config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a cron job\n\t */\n\tprivate async executeJob(jobId: string): Promise<void> {\n\t\tconst startTime = this.toMEZ(new Date());\n\n\t\ttry {\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tif (!job) {\n\t\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Executing job ${jobId}`);\n\n\t\t\t// Execute all targets\n\t\t\tfor (const target of job.config.targets) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Executing target ${target.id} with value ${target.value}`);\n\t\t\t\tawait this.executeTarget(target);\n\t\t\t}\n\n\t\t\t// Update status\n\t\t\tconst status: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.SUCCESS,\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING && job.config.cron\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = status;\n\t\t\tawait this.updateJobStatus(jobId, status);\n\n\t\t\t// Handle once-type jobs\n\t\t\tif (job.config.type === CRON_JOB_TYPE.ONCE) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: One-time job ${jobId} completed, deactivating`);\n\t\t\t\tjob.config.active = false;\n\t\t\t\tif (job.task) {\n\t\t\t\t\tjob.task.stop();\n\t\t\t\t\tjob.task = undefined;\n\t\t\t\t}\n\t\t\t\t// Remove nextRun for ONCE jobs after execution\n\t\t\t\tstatus.nextRun = undefined;\n\t\t\t\tawait this.updateJobStatus(jobId, status);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} executed successfully`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error executing job ${jobId}: ${error}`);\n\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tnextRun:\n\t\t\t\t\tjob?.config.active && job.config.type === CRON_JOB_TYPE.RECURRING && job.config.cron\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tif (job) {\n\t\t\t\tjob.status = errorStatus;\n\t\t\t}\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a single target\n\t */\n\tprivate async executeTarget(target: CronTarget): Promise<void> {\n\t\ttry {\n\t\t\t// Apply delay if specified\n\t\t\tif (target.delay && target.delay > 0) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Delaying execution of ${target.id} by ${target.delay}ms`);\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, target.delay));\n\t\t\t}\n\n\t\t\t// Resolve the target value based on type\n\t\t\tconst resolvedValue = await this.resolveTargetValue(target);\n\n\t\t\t// Set the state with proper acknowledgment\n\t\t\tawait this.adapter.setForeignStateAsync(target.id, {\n\t\t\t\tval: resolvedValue,\n\t\t\t\tack: false,\n\t\t\t});\n\t\t\tthis.adapter.log.debug(\n\t\t\t\t`CronJobManager: Set ${target.id} = ${resolvedValue} (type: ${target.type || CRON_TARGET_TYPE.VALUE})${target.delay ? ` after ${target.delay}ms delay` : \"\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = `Error setting ${target.id}: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tthis.adapter.log.error(`CronJobManager: ${errorMessage}`);\n\t\t\tthrow new CronJobError(\n\t\t\t\terrorMessage,\n\t\t\t\ttarget.id,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve target value based on type\n\t */\n\tprivate async resolveTargetValue(target: CronTarget): Promise<any> {\n\t\tconst targetType = target.type || CRON_TARGET_TYPE.VALUE;\n\n\t\tswitch (targetType) {\n\t\t\tcase CRON_TARGET_TYPE.VALUE:\n\t\t\t\t// Direct value\n\t\t\t\treturn target.value;\n\n\t\t\tcase CRON_TARGET_TYPE.STATE:\n\t\t\t\t// Get value from another state\n\t\t\t\ttry {\n\t\t\t\t\tconst sourceState = await this.adapter.getStateAsync(target.value as string);\n\t\t\t\t\tif (sourceState === null || sourceState === undefined) {\n\t\t\t\t\t\tthis.adapter.log.warn(`CronJobManager: Source state ${target.value} not found, using null`);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn sourceState.val;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error reading source state ${target.value}: ${error}`);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new CronJobError(`Unknown target type: ${targetType}`, target.id, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\t}\n\n\t/**\n\t * Update job status\n\t */\n\tprivate async updateJobStatus(jobId: string, status: CronJobStatus): Promise<void> {\n\t\ttry {\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.setForeignStateAsync(statusId, {\n\t\t\t\tval: JSON.stringify(status, null, 2),\n\t\t\t\tack: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating status for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Convert a date to MEZ/MESZ (Europe/Berlin) timezone and return as ISO string\n\t */\n\tprivate toMEZ(date: Date): string {\n\t\t// Create a date formatter for Berlin timezone\n\t\tconst formatter = new Intl.DateTimeFormat(\"en-CA\", {\n\t\t\ttimeZone: \"Europe/Berlin\",\n\t\t\tyear: \"numeric\",\n\t\t\tmonth: \"2-digit\",\n\t\t\tday: \"2-digit\",\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\",\n\t\t\tsecond: \"2-digit\",\n\t\t\thour12: false,\n\t\t});\n\n\t\t// Format the date parts\n\t\tconst parts = formatter.formatToParts(date);\n\t\tconst year = parts.find((p) => p.type === \"year\")?.value;\n\t\tconst month = parts.find((p) => p.type === \"month\")?.value;\n\t\tconst day = parts.find((p) => p.type === \"day\")?.value;\n\t\tconst hour = parts.find((p) => p.type === \"hour\")?.value;\n\t\tconst minute = parts.find((p) => p.type === \"minute\")?.value;\n\t\tconst second = parts.find((p) => p.type === \"second\")?.value;\n\n\t\t// Calculate timezone offset (automatically handles MEZ/MESZ switch)\n\t\t// Create a date in Berlin timezone and compare with UTC\n\t\tconst berlinTimeString = date.toLocaleString(\"en-US\", { timeZone: \"Europe/Berlin\" });\n\t\tconst utcTimeString = date.toLocaleString(\"en-US\", { timeZone: \"UTC\" });\n\t\tconst berlinTime = new Date(berlinTimeString);\n\t\tconst utcTime = new Date(utcTimeString);\n\t\tconst offsetMs = berlinTime.getTime() - utcTime.getTime();\n\t\tconst offsetHours = Math.floor(offsetMs / (1000 * 60 * 60));\n\t\tconst offsetMinutes = Math.abs(Math.floor((offsetMs % (1000 * 60 * 60)) / (1000 * 60)));\n\t\tconst offsetSign = offsetHours >= 0 ? \"+\" : \"-\";\n\t\tconst offsetString = `${offsetSign}${Math.abs(offsetHours).toString().padStart(2, \"0\")}:${offsetMinutes.toString().padStart(2, \"0\")}`;\n\n\t\t// Return ISO format with Berlin timezone offset\n\t\treturn `${year}-${month}-${day}T${hour}:${minute}:${second}${offsetString}`;\n\t}\n\n\t/**\n\t * Get next run time for a cron expression in MEZ\n\t */\n\tprivate getNextRunTime(cronExpression: string): string | undefined {\n\t\ttry {\n\t\t\t// Parse the cron expression with Berlin timezone\n\t\t\tconst interval = CronExpressionParser.parse(cronExpression, {\n\t\t\t\ttz: \"Europe/Berlin\",\n\t\t\t});\n\t\t\tconst nextRun = interval.next();\n\t\t\tif (!nextRun) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Convert to MEZ timezone string\n\t\t\treturn this.toMEZ(nextRun.toDate());\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.warn(`CronJobManager: Error calculating next run time for '${cronExpression}': ${error}`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Start periodic cleanup of orphaned objects\n\t */\n\tprivate startPeriodicCleanup(): void {\n\t\t// Run cleanup every 5 minutes\n\t\tthis.cleanupInterval = setInterval(\n\t\t\tasync () => {\n\t\t\t\tawait this.cleanupOrphanedObjects();\n\t\t\t},\n\t\t\t5 * 60 * 1000, // 5 minutes\n\t\t);\n\n\t\tthis.adapter.log.debug(\"CronJobManager: Started periodic cleanup of orphaned objects\");\n\t}\n\n\t/**\n\t * Clean up orphaned status and trigger objects\n\t */\n\tprivate async cleanupOrphanedObjects(): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(\"CronJobManager: Starting cleanup of orphaned objects\");\n\n\t\t\t// Get all objects in the adapter namespace\n\t\t\tconst objects = await this.adapter.getObjectListAsync({\n\t\t\t\tstartkey: this.adapter.namespace,\n\t\t\t\tendkey: this.adapter.namespace + \"\\u9999\",\n\t\t\t});\n\n\t\t\tconst orphanedObjects: string[] = [];\n\n\t\t\t// Check for orphaned status and trigger objects\n\t\t\tfor (const obj of objects.rows) {\n\t\t\t\tconst objId = obj.id;\n\n\t\t\t\t// Check if this is a status or trigger object\n\t\t\t\tif (objId.endsWith(\".status\") || objId.endsWith(\".trigger\")) {\n\t\t\t\t\t// Extract the job ID by removing the suffix\n\t\t\t\t\tconst jobId = objId.replace(/\\.(status|trigger)$/, \"\");\n\n\t\t\t\t\t// Check if the corresponding job exists\n\t\t\t\t\tif (!this.jobs.has(jobId)) {\n\t\t\t\t\t\t// Check if the job state object exists\n\t\t\t\t\t\tconst jobStateExists = await this.checkJobStateExists(jobId);\n\t\t\t\t\t\tif (!jobStateExists) {\n\t\t\t\t\t\t\torphanedObjects.push(objId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove orphaned objects\n\t\t\tfor (const objId of orphanedObjects) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.adapter.delObjectAsync(objId);\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Cleaned up orphaned object ${objId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.warn(`CronJobManager: Error removing orphaned object ${objId}: ${error}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (orphanedObjects.length > 0) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Cleaned up ${orphanedObjects.length} orphaned objects`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error during orphaned objects cleanup: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a job state object exists\n\t */\n\tprivate async checkJobStateExists(jobId: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\treturn state !== null && state !== undefined;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["statusId", "CronExpressionParser"]
}
