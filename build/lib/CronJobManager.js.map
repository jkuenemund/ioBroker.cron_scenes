{
  "version": 3,
  "sources": ["../../src/lib/CronJobManager.ts"],
  "sourcesContent": ["import * as cron from \"node-cron\";\n\n/**\n * Constants for cron job status and types\n */\nexport const CRON_JOB_STATUS = {\n\tSUCCESS: \"success\",\n\tERROR: \"error\",\n\tPENDING: \"pending\",\n} as const;\n\nexport const CRON_JOB_TYPE = {\n\tONCE: \"once\",\n\tRECURRING: \"recurring\",\n} as const;\n\nexport type CronJobStatusType = (typeof CRON_JOB_STATUS)[keyof typeof CRON_JOB_STATUS];\nexport type CronJobTypeType = (typeof CRON_JOB_TYPE)[keyof typeof CRON_JOB_TYPE];\n\n/**\n * Custom error types for better error handling\n */\nexport const CRON_ERROR_CODE = {\n\tINVALID_CRON: \"INVALID_CRON\",\n\tTARGET_NOT_FOUND: \"TARGET_NOT_FOUND\",\n\tEXECUTION_FAILED: \"EXECUTION_FAILED\",\n\tCONFIG_INVALID: \"CONFIG_INVALID\",\n} as const;\n\nexport type CronErrorCode = (typeof CRON_ERROR_CODE)[keyof typeof CRON_ERROR_CODE];\n\nexport class CronJobError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic readonly jobId: string,\n\t\tpublic readonly code: CronErrorCode,\n\t\tpublic readonly originalError?: Error,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"CronJobError\";\n\t}\n}\n\n/**\n * Configuration validation utilities\n */\nexport class ConfigValidator {\n\t/**\n\t * Validate a cron job configuration\n\t */\n\tstatic validateCronJobConfig(config: any, jobId: string): CronJobConfig {\n\t\tif (!config || typeof config !== \"object\") {\n\t\t\tthrow new CronJobError(\"Configuration must be an object\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\t// Validate cron expression\n\t\tif (!config.cron || typeof config.cron !== \"string\") {\n\t\t\tthrow new CronJobError(\n\t\t\t\t\"Cron expression is required and must be a string\",\n\t\t\t\tjobId,\n\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t);\n\t\t}\n\n\t\tif (!cron.validate(config.cron)) {\n\t\t\tthrow new CronJobError(`Invalid cron expression: ${config.cron}`, jobId, CRON_ERROR_CODE.INVALID_CRON);\n\t\t}\n\n\t\t// Validate targets\n\t\tif (!Array.isArray(config.targets) || config.targets.length === 0) {\n\t\t\tthrow new CronJobError(\"Targets must be a non-empty array\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\tconst validatedTargets: CronTarget[] = config.targets.map((target: any, index: number) => {\n\t\t\tif (!target || typeof target !== \"object\") {\n\t\t\t\tthrow new CronJobError(`Target ${index} must be an object`, jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\tif (!target.id || typeof target.id !== \"string\") {\n\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t`Target ${index} id is required and must be a string`,\n\t\t\t\t\tjobId,\n\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (target.value === undefined || target.value === null) {\n\t\t\t\tthrow new CronJobError(`Target ${index} value is required`, jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t\t}\n\n\t\t\t// Validate value type\n\t\t\tconst valueType = typeof target.value;\n\t\t\tif (![\"string\", \"number\", \"boolean\"].includes(valueType) && target.value !== null) {\n\t\t\t\tthrow new CronJobError(\n\t\t\t\t\t`Target ${index} value must be string, number, boolean, or null`,\n\t\t\t\t\tjobId,\n\t\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: target.id,\n\t\t\t\tvalue: target.value,\n\t\t\t\tdescription: target.description || undefined,\n\t\t\t};\n\t\t});\n\n\t\t// Validate active flag\n\t\tif (typeof config.active !== \"boolean\") {\n\t\t\tthrow new CronJobError(\"Active flag must be a boolean\", jobId, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\n\t\t// Validate type\n\t\tif (!config.type || !Object.values(CRON_JOB_TYPE).includes(config.type)) {\n\t\t\tthrow new CronJobError(\n\t\t\t\t`Type must be one of: ${Object.values(CRON_JOB_TYPE).join(\", \")}`,\n\t\t\t\tjobId,\n\t\t\t\tCRON_ERROR_CODE.CONFIG_INVALID,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tcron: config.cron,\n\t\t\ttargets: validatedTargets,\n\t\t\tactive: config.active,\n\t\t\ttype: config.type,\n\t\t\terror: config.error || null,\n\t\t};\n\t}\n}\n\n/**\n * Interface for a cron job target\n */\nexport interface CronTarget {\n\tid: string;\n\tvalue: string | number | boolean | null;\n\tdescription?: string;\n}\n\n/**\n * Interface for a cron job configuration\n */\nexport interface CronJobConfig {\n\tcron: string;\n\ttargets: CronTarget[];\n\tactive: boolean;\n\ttype: CronJobTypeType;\n\terror?: string | null;\n}\n\n/**\n * Interface for a cron job status\n */\nexport interface CronJobStatus {\n\tlastRun?: string;\n\tstatus: CronJobStatusType;\n\tnextRun?: string;\n\terror?: string | null;\n}\n\n/**\n * Interface for adapter methods used by CronJobManager\n */\nexport interface AdapterInterface {\n\tlog: ioBroker.Logger;\n\tconfig: {\n\t\tcronFolder?: string;\n\t\tenableLogging?: boolean;\n\t\tdefaultJobsActive?: boolean;\n\t\tmaxConcurrentJobs?: number;\n\t\tjobTimeout?: number;\n\t};\n\tnamespace: string;\n\tsetState(id: string, state: ioBroker.SettableState): void;\n\tsetStateAsync(id: string, state: ioBroker.SettableState): any;\n\tgetStateAsync(id: string): any;\n\tgetStatesAsync(pattern: string): any;\n\tgetObjectAsync(id: string): any;\n\tsetObjectAsync(id: string, obj: ioBroker.SettableObject): any;\n\tsetObjectNotExistsAsync(id: string, obj: ioBroker.SettableObject): any;\n\tsetForeignStateAsync(id: string, state: ioBroker.SettableState): any;\n}\n\n/**\n * Interface for a registered cron job\n */\ninterface RegisteredCronJob {\n\tid: string;\n\tconfig: CronJobConfig;\n\ttask?: cron.ScheduledTask;\n\tstatus: CronJobStatus;\n}\n\n/**\n * CronJobManager handles all cron job operations\n */\nexport class CronJobManager {\n\tprivate adapter: AdapterInterface;\n\tprivate jobs: Map<string, RegisteredCronJob> = new Map();\n\tprivate checkInterval?: NodeJS.Timeout;\n\n\tconstructor(adapter: AdapterInterface) {\n\t\tthis.adapter = adapter;\n\t}\n\n\t/**\n\t * Initialize the cron job manager\n\t */\n\tpublic initialize(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Initializing...\");\n\n\t\t// Perform initial scan for existing jobs\n\t\tthis.checkForJobChanges();\n\n\t\tthis.adapter.log.info(\"CronJobManager: Initialized (event-driven mode)\");\n\t}\n\n\t/**\n\t * Shutdown the cron job manager\n\t */\n\tpublic shutdown(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Shutting down...\");\n\n\t\t// Stop all running jobs\n\t\tfor (const [jobId, job] of this.jobs) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Stopped job ${jobId}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.jobs.clear();\n\t\tthis.adapter.log.info(\"CronJobManager: Shutdown complete\");\n\t}\n\n\t/**\n\t * Add or update a cron job\n\t */\n\tpublic async addOrUpdateJob(jobId: string, config: any): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Adding/updating job ${jobId}`);\n\n\t\t\t// Validate and sanitize configuration\n\t\t\tconst validatedConfig = ConfigValidator.validateCronJobConfig(config, jobId);\n\n\t\t\t// Stop existing job if it exists\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob?.task) {\n\t\t\t\texistingJob.task.stop();\n\t\t\t}\n\n\t\t\t// Create new job\n\t\t\tconst newJob: RegisteredCronJob = {\n\t\t\t\tid: jobId,\n\t\t\t\tconfig: { ...validatedConfig },\n\t\t\t\tstatus: {\n\t\t\t\t\tstatus: CRON_JOB_STATUS.PENDING,\n\t\t\t\t\tnextRun: validatedConfig.active ? this.getNextRunTime(validatedConfig.cron) : undefined,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create and start cron task if active\n\t\t\tif (validatedConfig.active) {\n\t\t\t\tnewJob.task = cron.schedule(validatedConfig.cron, () => {\n\t\t\t\t\tthis.executeJob(jobId);\n\t\t\t\t});\n\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Started job ${jobId} with cron '${validatedConfig.cron}'`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} created but not active`);\n\t\t\t}\n\n\t\t\t// Register job\n\t\t\tthis.jobs.set(jobId, newJob);\n\n\t\t\t// Create trigger object if it doesn't exist\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(triggerId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Manual Trigger\",\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\tread: false,\n\t\t\t\t\twrite: true,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Update job status in state\n\t\t\tawait this.updateJobStatus(jobId, newJob.status);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error adding job ${jobId}: ${error}`);\n\n\t\t\t// Update error status\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t};\n\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a cron job\n\t */\n\tpublic removeJob(jobId: string): void {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (job) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t}\n\t\t\tthis.jobs.delete(jobId);\n\t\t\tthis.adapter.log.info(`CronJobManager: Removed job ${jobId}`);\n\t\t}\n\t}\n\n\t/**\n\t * Handle job state change (called from adapter onStateChange)\n\t */\n\tpublic async handleJobStateChange(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Handling state change for job ${jobId}`);\n\n\t\t\t// Get current state and object\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\n\t\t\tif (!state || !obj) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: State or object not found for job ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet config: CronJobConfig;\n\n\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from state value for job ${jobId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error parsing job config from state ${jobId}: ${error}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from native object for job ${jobId}`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (!existingJob || JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tif (existingJob) {\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Configuration changed for job ${jobId}, removing old job`);\n\t\t\t\t\tthis.removeJob(jobId);\n\t\t\t\t}\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Adding job ${jobId} with new configuration`);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error handling state change for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a job\n\t */\n\tpublic async triggerJob(jobId: string): Promise<void> {\n\t\t// Before triggering, ensure we have the latest configuration\n\t\tawait this.refreshJobConfig(jobId);\n\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t}\n\n\t\tthis.adapter.log.info(`CronJobManager: Manually triggering job ${jobId}`);\n\t\tawait this.executeJob(jobId);\n\t}\n\n\t/**\n\t * Refresh job configuration from current state\n\t */\n\tprivate async refreshJobConfig(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state value\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\n\t\t\tif (!state || !obj) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: Could not refresh config for job ${jobId} - state or object not found`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet config: CronJobConfig;\n\n\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from state value for job ${jobId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error parsing job config from state ${jobId}: ${error}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from native object for job ${jobId}`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId} during refresh`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate config\n\t\t\tif (!config.cron || !config.targets) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`CronJobManager: Invalid refreshed config for job ${jobId}: missing cron or targets`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob && JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Config changed during refresh for job ${jobId}, updating job`);\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tthis.removeJob(jobId);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error refreshing job config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a cron job\n\t */\n\tprivate async executeJob(jobId: string): Promise<void> {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Job ${jobId} not found for execution`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = new Date().toISOString();\n\t\tthis.adapter.log.info(`CronJobManager: Executing job ${jobId}`);\n\n\t\ttry {\n\t\t\t// Execute all targets\n\t\t\tthis.adapter.log.debug(`CronJobManager: Job ${jobId} has ${job.config.targets.length} targets to execute`);\n\t\t\tfor (const target of job.config.targets) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Executing target ${target.id} with value ${target.value}`);\n\t\t\t\tawait this.executeTarget(target);\n\t\t\t}\n\n\t\t\t// Update status\n\t\t\tconst status: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.SUCCESS,\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = status;\n\t\t\tawait this.updateJobStatus(jobId, status);\n\n\t\t\t// Handle once-type jobs\n\t\t\tif (job.config.type === CRON_JOB_TYPE.ONCE) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: One-time job ${jobId} completed, deactivating`);\n\t\t\t\tjob.config.active = false;\n\t\t\t\tif (job.task) {\n\t\t\t\t\tjob.task.stop();\n\t\t\t\t}\n\n\t\t\t\t// Update the job state to inactive\n\t\t\t\tawait this.updateJobConfig(jobId, job.config);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} executed successfully`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error executing job ${jobId}: ${error}`);\n\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = errorStatus;\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a single target\n\t */\n\tprivate async executeTarget(target: CronTarget): Promise<void> {\n\t\ttry {\n\t\t\t// Set the state with proper acknowledgment\n\t\t\tawait this.adapter.setForeignStateAsync(target.id, {\n\t\t\t\tval: target.value,\n\t\t\t\tack: false,\n\t\t\t});\n\t\t\tthis.adapter.log.debug(`CronJobManager: Set ${target.id} = ${target.value}`);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = `Error setting ${target.id}: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tthis.adapter.log.error(`CronJobManager: ${errorMessage}`);\n\t\t\tthrow new CronJobError(\n\t\t\t\terrorMessage,\n\t\t\t\ttarget.id,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Update job status in ioBroker state\n\t */\n\tprivate async updateJobStatus(jobId: string, status: CronJobStatus): Promise<void> {\n\t\ttry {\n\t\t\t// Create a status state instead of overwriting the job state\n\t\t\tconst statusId = jobId + \".status\";\n\n\t\t\t// Ensure the status object exists\n\t\t\tawait this.adapter.setObjectNotExistsAsync(statusId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Job Status\",\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trole: \"json\",\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Set the status value\n\t\t\tthis.adapter.setState(statusId, {\n\t\t\t\tval: JSON.stringify(status),\n\t\t\t\tack: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating status for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Update job config in ioBroker state\n\t */\n\tprivate async updateJobConfig(jobId: string, config: CronJobConfig): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tif (state) {\n\t\t\t\t// Update the state with new config in common.native\n\t\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.native = config;\n\t\t\t\t\tawait this.adapter.setObjectAsync(jobId, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get next run time for a cron expression\n\t */\n\tprivate getNextRunTime(cronExpression: string): string | undefined {\n\t\ttry {\n\t\t\t// This is a simplified implementation\n\t\t\t// In a real implementation, you'd use a proper cron parser\n\t\t\tconst now = new Date();\n\t\t\tconst nextRun = new Date(now.getTime() + 60000); // Simple: next minute\n\t\t\treturn nextRun.toISOString();\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error calculating next run time: ${error}`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Initial scan for existing jobs (called once during initialization)\n\t */\n\tprivate async checkForJobChanges(): Promise<void> {\n\t\ttry {\n\t\t\tconst cronFolder = this.adapter.config.cronFolder || `${this.adapter.namespace}.jobs`;\n\n\t\t\t// Get all states in the cron folder\n\t\t\tconst states = await this.adapter.getStatesAsync(`${cronFolder}.*`);\n\t\t\tif (!states) {\n\t\t\t\tthis.adapter.log.debug(\"CronJobManager: No existing jobs found during initialization\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.adapter.log.debug(`CronJobManager: Found ${Object.keys(states).length} states during initialization`);\n\n\t\t\t// Process each state\n\t\t\tfor (const [stateId, state] of Object.entries(states)) {\n\t\t\t\t// Skip trigger states, status states and non-job states\n\t\t\t\tif (stateId.endsWith(\".trigger\") || stateId.endsWith(\".status\") || !state) continue;\n\n\t\t\t\t// Process this job using the new event-driven method\n\t\t\t\tawait this.handleJobStateChange(stateId);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Initialized ${this.jobs.size} jobs`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error during initial job scan: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get status of all jobs\n\t */\n\tpublic getJobsStatus(): Array<{ id: string; config: CronJobConfig; status: CronJobStatus }> {\n\t\treturn Array.from(this.jobs.values()).map((job) => ({\n\t\t\tid: job.id,\n\t\t\tconfig: job.config,\n\t\t\tstatus: job.status,\n\t\t}));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
