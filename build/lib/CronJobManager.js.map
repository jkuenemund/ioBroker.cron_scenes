{
  "version": 3,
  "sources": ["../../src/lib/CronJobManager.ts"],
  "sourcesContent": ["import * as cron from \"node-cron\";\n\n/**\n * Interface for a cron job configuration\n */\nexport interface CronJobConfig {\n\tcron: string;\n\ttargets: Array<{\n\t\tid: string;\n\t\tvalue: any;\n\t}>;\n\tactive: boolean;\n\ttype: \"once\" | \"recurring\";\n\terror?: string | null;\n}\n\n/**\n * Interface for a cron job status\n */\nexport interface CronJobStatus {\n\tlastRun?: string;\n\tstatus: \"success\" | \"error\" | \"pending\";\n\tnextRun?: string;\n\terror?: string | null;\n}\n\n/**\n * Interface for a registered cron job\n */\ninterface RegisteredCronJob {\n\tid: string;\n\tconfig: CronJobConfig;\n\ttask?: cron.ScheduledTask;\n\tstatus: CronJobStatus;\n}\n\n/**\n * CronJobManager handles all cron job operations\n */\nexport class CronJobManager {\n\tprivate adapter: any; // Use any to avoid TypeScript export issues\n\tprivate jobs: Map<string, RegisteredCronJob> = new Map();\n\tprivate checkInterval?: NodeJS.Timeout;\n\n\tconstructor(adapter: any) {\n\t\tthis.adapter = adapter;\n\t}\n\n\t/**\n\t * Initialize the cron job manager\n\t */\n\tpublic initialize(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Initializing...\");\n\n\t\t// Start periodic check for job state changes\n\t\tconst interval = this.adapter.config.checkInterval || 30;\n\t\tthis.checkInterval = setInterval(() => {\n\t\t\tthis.checkForJobChanges();\n\t\t}, interval * 1000);\n\n\t\tthis.adapter.log.info(`CronJobManager: Initialized with ${interval}s check interval`);\n\t}\n\n\t/**\n\t * Shutdown the cron job manager\n\t */\n\tpublic shutdown(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Shutting down...\");\n\n\t\t// Clear check interval\n\t\tif (this.checkInterval) {\n\t\t\tclearInterval(this.checkInterval);\n\t\t\tthis.checkInterval = undefined;\n\t\t}\n\n\t\t// Stop all running jobs\n\t\tfor (const [jobId, job] of this.jobs) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Stopped job ${jobId}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.jobs.clear();\n\t\tthis.adapter.log.info(\"CronJobManager: Shutdown complete\");\n\t}\n\n\t/**\n\t * Add or update a cron job\n\t */\n\tpublic async addOrUpdateJob(jobId: string, config: CronJobConfig): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Adding/updating job ${jobId}`);\n\n\t\t\t// Validate cron expression\n\t\t\tif (!cron.validate(config.cron)) {\n\t\t\t\tthrow new Error(`Invalid cron expression: ${config.cron}`);\n\t\t\t}\n\n\t\t\t// Stop existing job if it exists\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob?.task) {\n\t\t\t\texistingJob.task.stop();\n\t\t\t}\n\n\t\t\t// Create new job\n\t\t\tconst newJob: RegisteredCronJob = {\n\t\t\t\tid: jobId,\n\t\t\t\tconfig: { ...config },\n\t\t\t\tstatus: {\n\t\t\t\t\tstatus: \"pending\",\n\t\t\t\t\tnextRun: config.active ? this.getNextRunTime(config.cron) : undefined,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create and start cron task if active\n\t\t\tif (config.active) {\n\t\t\t\tnewJob.task = cron.schedule(config.cron, () => {\n\t\t\t\t\tthis.executeJob(jobId);\n\t\t\t\t});\n\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Started job ${jobId} with cron '${config.cron}'`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} created but not active`);\n\t\t\t}\n\n\t\t\t// Register job\n\t\t\tthis.jobs.set(jobId, newJob);\n\n\t\t\t// Create trigger object if it doesn't exist\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(triggerId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Manual Trigger\",\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\tread: false,\n\t\t\t\t\twrite: true,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Update job status in state\n\t\t\tawait this.updateJobStatus(jobId, newJob.status);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error adding job ${jobId}: ${error}`);\n\n\t\t\t// Update error status\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tstatus: \"error\",\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t};\n\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a cron job\n\t */\n\tpublic removeJob(jobId: string): void {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (job) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t}\n\t\t\tthis.jobs.delete(jobId);\n\t\t\tthis.adapter.log.info(`CronJobManager: Removed job ${jobId}`);\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a job\n\t */\n\tpublic async triggerJob(jobId: string): Promise<void> {\n\t\t// Before triggering, ensure we have the latest configuration\n\t\tawait this.refreshJobConfig(jobId);\n\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthrow new Error(`Job ${jobId} not found`);\n\t\t}\n\n\t\tthis.adapter.log.info(`CronJobManager: Manually triggering job ${jobId}`);\n\t\tawait this.executeJob(jobId);\n\t}\n\n\t/**\n\t * Refresh job configuration from current state\n\t */\n\tprivate async refreshJobConfig(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state value\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\n\t\t\tif (!state || !obj) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: Could not refresh config for job ${jobId} - state or object not found`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet config: CronJobConfig;\n\n\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from state value for job ${jobId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error parsing job config from state ${jobId}: ${error}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Refreshed config from native object for job ${jobId}`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId} during refresh`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate config\n\t\t\tif (!config.cron || !config.targets) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`CronJobManager: Invalid refreshed config for job ${jobId}: missing cron or targets`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob && JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Config changed during refresh for job ${jobId}, updating job`);\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tthis.removeJob(jobId);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error refreshing job config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a cron job\n\t */\n\tprivate async executeJob(jobId: string): Promise<void> {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (!job) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Job ${jobId} not found for execution`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = new Date().toISOString();\n\t\tthis.adapter.log.info(`CronJobManager: Executing job ${jobId}`);\n\n\t\ttry {\n\t\t\t// Execute all targets\n\t\t\tthis.adapter.log.debug(`CronJobManager: Job ${jobId} has ${job.config.targets.length} targets to execute`);\n\t\t\tfor (const target of job.config.targets) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Executing target ${target.id} with value ${target.value}`);\n\t\t\t\tawait this.executeTarget(target);\n\t\t\t}\n\n\t\t\t// Update status\n\t\t\tconst status: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: \"success\",\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === \"recurring\"\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = status;\n\t\t\tawait this.updateJobStatus(jobId, status);\n\n\t\t\t// Handle once-type jobs\n\t\t\tif (job.config.type === \"once\") {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: One-time job ${jobId} completed, deactivating`);\n\t\t\t\tjob.config.active = false;\n\t\t\t\tif (job.task) {\n\t\t\t\t\tjob.task.stop();\n\t\t\t\t}\n\n\t\t\t\t// Update the job state to inactive\n\t\t\t\tawait this.updateJobConfig(jobId, job.config);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} executed successfully`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error executing job ${jobId}: ${error}`);\n\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: \"error\",\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === \"recurring\"\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = errorStatus;\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a single target\n\t */\n\tprivate async executeTarget(target: { id: string; value: any }): Promise<void> {\n\t\ttry {\n\t\t\t// Set the state with proper acknowledgment\n\t\t\tawait this.adapter.setForeignStateAsync(target.id, {\n\t\t\t\tval: target.value,\n\t\t\t\tack: false,\n\t\t\t});\n\t\t\tthis.adapter.log.debug(`CronJobManager: Set ${target.id} = ${target.value}`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error setting ${target.id}: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Update job status in ioBroker state\n\t */\n\tprivate async updateJobStatus(jobId: string, status: CronJobStatus): Promise<void> {\n\t\ttry {\n\t\t\t// Create a status state instead of overwriting the job state\n\t\t\tconst statusId = jobId + \".status\";\n\n\t\t\t// Ensure the status object exists\n\t\t\tawait this.adapter.setObjectNotExistsAsync(statusId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: \"Job Status\",\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trole: \"json\",\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t});\n\n\t\t\t// Set the status value\n\t\t\tawait this.adapter.setStateAsync(statusId, {\n\t\t\t\tval: JSON.stringify(status),\n\t\t\t\tack: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating status for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Update job config in ioBroker state\n\t */\n\tprivate async updateJobConfig(jobId: string, config: CronJobConfig): Promise<void> {\n\t\ttry {\n\t\t\t// Get current state\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\tif (state) {\n\t\t\t\t// Update the state with new config in common.native\n\t\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\t\t\t\tif (obj) {\n\t\t\t\t\tobj.native = config;\n\t\t\t\t\tawait this.adapter.setObjectAsync(jobId, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get next run time for a cron expression\n\t */\n\tprivate getNextRunTime(cronExpression: string): string | undefined {\n\t\ttry {\n\t\t\t// This is a simplified implementation\n\t\t\t// In a real implementation, you'd use a proper cron parser\n\t\t\tconst now = new Date();\n\t\t\tconst nextRun = new Date(now.getTime() + 60000); // Simple: next minute\n\t\t\treturn nextRun.toISOString();\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error calculating next run time: ${error}`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Check for job state changes\n\t */\n\tprivate async checkForJobChanges(): Promise<void> {\n\t\ttry {\n\t\t\tconst cronFolder = this.adapter.config.cronFolder || `${this.adapter.namespace}.jobs`;\n\n\t\t\t// Get all states in the cron folder\n\t\t\tconst states = await this.adapter.getStatesAsync(`${cronFolder}.*`);\n\n\t\t\tif (!states) return;\n\n\t\t\t// Process each state\n\t\t\tfor (const [stateId, state] of Object.entries(states)) {\n\t\t\t\t// Skip trigger states, status states and non-job states\n\t\t\t\tif (stateId.endsWith(\".trigger\") || stateId.endsWith(\".status\") || !state) continue;\n\n\t\t\t\tconst jobId = stateId;\n\n\t\t\t\t// Get job configuration from object\n\t\t\t\tconst obj = await this.adapter.getObjectAsync(jobId);\n\t\t\t\tif (!obj) continue;\n\n\t\t\t\tlet config: CronJobConfig;\n\n\t\t\t\t// Try to get config from state value first, then from native as fallback\n\t\t\t\tif ((state as any).val && typeof (state as any).val === \"string\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconfig = JSON.parse((state as any).val) as CronJobConfig;\n\t\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from state value for job ${jobId}`);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t\t\t`CronJobManager: Error parsing job config from state ${jobId}: ${error}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (obj.native && (obj.native as any).cron) {\n\t\t\t\t\tconfig = obj.native as CronJobConfig;\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: Using config from native object for job ${jobId}`);\n\t\t\t\t} else {\n\t\t\t\t\tthis.adapter.log.debug(`CronJobManager: No valid config found for job ${jobId}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Validate config\n\t\t\t\tif (!config.cron || !config.targets) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Invalid config for job ${jobId}: missing cron or targets`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if job needs to be updated\n\t\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\t\tif (!existingJob || JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\t\tif (existingJob) {\n\t\t\t\t\t\tthis.adapter.log.info(\n\t\t\t\t\t\t\t`CronJobManager: Configuration changed for job ${jobId}, removing old job`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.removeJob(jobId);\n\t\t\t\t\t}\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Adding job ${jobId} with new configuration`);\n\t\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove jobs that no longer exist\n\t\t\tfor (const jobId of this.jobs.keys()) {\n\t\t\t\tif (!states[jobId]) {\n\t\t\t\t\tthis.removeJob(jobId);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error checking for job changes: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get status of all jobs\n\t */\n\tpublic getJobsStatus(): Array<{ id: string; config: CronJobConfig; status: CronJobStatus }> {\n\t\treturn Array.from(this.jobs.values()).map((job) => ({\n\t\t\tid: job.id,\n\t\t\tconfig: job.config,\n\t\t\tstatus: job.status,\n\t\t}));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
