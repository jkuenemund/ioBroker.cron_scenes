{
  "version": 3,
  "sources": ["../../src/lib/CronJobManager.ts"],
  "sourcesContent": ["import * as cron from \"node-cron\";\nimport { ConfigValidator } from \"./ConfigValidator\";\nimport { CRON_JOB_STATUS, CRON_JOB_TYPE, CRON_TARGET_TYPE } from \"./constants\";\nimport { CRON_ERROR_CODE, CronJobError } from \"./errors\";\nimport { AdapterInterface, CronJobConfig, CronJobStatus, CronTarget, RegisteredCronJob } from \"./interfaces\";\n\n// Re-export for backward compatibility\nexport { CRON_ERROR_CODE, CRON_JOB_STATUS, CRON_JOB_TYPE, CRON_TARGET_TYPE, CronJobError };\nexport type { AdapterInterface, CronJobConfig, CronJobStatus, CronTarget, RegisteredCronJob };\n\n/**\n * CronJobManager - Manages cron jobs for the adapter\n */\nexport class CronJobManager {\n\tprivate jobs = new Map<string, RegisteredCronJob>();\n\tprivate cleanupInterval: NodeJS.Timeout | null = null;\n\n\tconstructor(private adapter: AdapterInterface) {}\n\n\t/**\n\t * Initialize the cron job manager\n\t */\n\tpublic initialize(): void {\n\t\tthis.adapter.log.info(\"CronJobManager: Initializing...\");\n\t\tthis.adapter.log.info(\"CronJobManager: Initialized (event-driven mode)\");\n\n\t\t// Start periodic cleanup of orphaned objects\n\t\tthis.startPeriodicCleanup();\n\t}\n\n\t/**\n\t * Shutdown the cron job manager\n\t */\n\tpublic async shutdown(): Promise<void> {\n\t\tthis.adapter.log.info(\"CronJobManager: Shutting down...\");\n\n\t\t// Stop cleanup interval\n\t\tif (this.cleanupInterval) {\n\t\t\tclearInterval(this.cleanupInterval);\n\t\t\tthis.cleanupInterval = null;\n\t\t}\n\n\t\t// Stop all running jobs\n\t\tfor (const [jobId, job] of this.jobs) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Stopped job ${jobId}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.jobs.clear();\n\t\tthis.adapter.log.info(\"CronJobManager: Shutdown complete\");\n\t}\n\n\t/**\n\t * Add or update a cron job\n\t */\n\tpublic async addOrUpdateJob(jobId: string, config: any): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(`CronJobManager: Adding/updating job ${jobId}`);\n\n\t\t\t// Validate and sanitize configuration\n\t\t\tconst validatedConfig = ConfigValidator.validateCronJobConfig(config, jobId);\n\n\t\t\t// Stop existing job if it exists\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob?.task) {\n\t\t\t\texistingJob.task.stop();\n\t\t\t}\n\n\t\t\t// Create new job\n\t\t\tconst newJob: RegisteredCronJob = {\n\t\t\t\tid: jobId,\n\t\t\t\tconfig: { ...validatedConfig },\n\t\t\t\tstatus: {\n\t\t\t\t\tstatus: CRON_JOB_STATUS.PENDING,\n\t\t\t\t\tnextRun:\n\t\t\t\t\t\tvalidatedConfig.active && validatedConfig.type !== CRON_JOB_TYPE.MANUAL && validatedConfig.cron\n\t\t\t\t\t\t\t? this.getNextRunTime(validatedConfig.cron)\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create and start cron task if active and not manual\n\t\t\tif (validatedConfig.active && validatedConfig.type !== CRON_JOB_TYPE.MANUAL && validatedConfig.cron) {\n\t\t\t\tnewJob.task = cron.schedule(validatedConfig.cron, () => {\n\t\t\t\t\tthis.executeJob(jobId);\n\t\t\t\t});\n\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Started job ${jobId} with cron '${validatedConfig.cron}'`);\n\t\t\t} else if (validatedConfig.type === CRON_JOB_TYPE.MANUAL) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Manual job ${jobId} created - trigger only execution`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} created but not active`);\n\t\t\t}\n\n\t\t\t// Register job\n\t\t\tthis.jobs.set(jobId, newJob);\n\n\t\t\t// Create trigger object if it doesn't exist\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(triggerId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: `Manual trigger for ${jobId}`,\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\trole: \"button\",\n\t\t\t\t\tread: false,\n\t\t\t\t\twrite: true,\n\t\t\t\t\tdesc: \"Set to true to manually trigger this job\",\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t\tacl: {\n\t\t\t\t\towner: \"system.user.admin\",\n\t\t\t\t\townerGroup: \"system.group.administrator\",\n\t\t\t\t\tobject: 0x666, // rw-rw-rw- (alle k\u00F6nnen lesen und schreiben)\n\t\t\t\t\tstate: 0x666, // rw-rw-rw- (alle k\u00F6nnen lesen und schreiben)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Create status object if it doesn't exist\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.setObjectNotExistsAsync(statusId, {\n\t\t\t\ttype: \"state\",\n\t\t\t\tcommon: {\n\t\t\t\t\tname: `Status for ${jobId}`,\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trole: \"json\",\n\t\t\t\t\tread: true,\n\t\t\t\t\twrite: false,\n\t\t\t\t\tdesc: \"Current status of this job\",\n\t\t\t\t},\n\t\t\t\tnative: {},\n\t\t\t\tacl: {\n\t\t\t\t\towner: \"system.user.admin\",\n\t\t\t\t\townerGroup: \"system.group.administrator\",\n\t\t\t\t\tobject: 0x644, // rw-r--r-- (Owner: read+write, alle anderen: read)\n\t\t\t\t\tstate: 0x644, // rw-r--r-- (Owner: read+write, alle anderen: read)\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Update status\n\t\t\tawait this.updateJobStatus(jobId, newJob.status);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error adding/updating job ${jobId}: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a cron job and clean up associated objects\n\t */\n\tpublic async removeJob(jobId: string): Promise<void> {\n\t\tconst job = this.jobs.get(jobId);\n\t\tif (job) {\n\t\t\tif (job.task) {\n\t\t\t\tjob.task.stop();\n\t\t\t}\n\t\t\tthis.jobs.delete(jobId);\n\t\t\tthis.adapter.log.info(`CronJobManager: Removed job ${jobId}`);\n\t\t}\n\n\t\t// Clean up associated status and trigger objects\n\t\tawait this.cleanupJobObjects(jobId);\n\t}\n\n\t/**\n\t * Clean up status and trigger objects for a job\n\t */\n\tprivate async cleanupJobObjects(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\t// Remove status object\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.delObjectAsync(statusId);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up status object ${statusId}`);\n\n\t\t\t// Remove trigger object\n\t\t\tconst triggerId = jobId + \".trigger\";\n\t\t\tawait this.adapter.delObjectAsync(triggerId);\n\t\t\tthis.adapter.log.debug(`CronJobManager: Cleaned up trigger object ${triggerId}`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.warn(`CronJobManager: Error cleaning up objects for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get all registered jobs\n\t */\n\tpublic getJobs(): Map<string, RegisteredCronJob> {\n\t\treturn new Map(this.jobs);\n\t}\n\n\t/**\n\t * Handle state changes for job configurations\n\t */\n\tpublic async handleJobStateChange(jobId: string, state: any): Promise<void> {\n\t\ttry {\n\t\t\tif (!state || !state.val) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Ignoring empty state change for ${jobId}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Parse configuration\n\t\t\tlet config: any;\n\t\t\ttry {\n\t\t\t\tconfig = JSON.parse(state.val);\n\t\t\t} catch (parseError) {\n\t\t\t\tthis.adapter.log.error(`CronJobManager: Invalid JSON configuration for job ${jobId}: ${parseError}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (!existingJob || JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tif (existingJob) {\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Configuration changed for job ${jobId}, removing old job`);\n\t\t\t\t\tthis.removeJob(jobId);\n\t\t\t\t}\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Adding job ${jobId} with new configuration`);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error handling state change for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a job\n\t */\n\tpublic async triggerJob(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.info(`CronJobManager: Manual trigger requested for job ${jobId}`);\n\n\t\t\t// First, refresh the job configuration to ensure we have the latest version\n\t\t\tawait this.refreshJobConfig(jobId);\n\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tif (!job) {\n\t\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t\t}\n\n\t\t\tif (!job.config.active) {\n\t\t\t\tthis.adapter.log.warn(`CronJobManager: Job ${jobId} is not active, skipping manual trigger`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait this.executeJob(jobId);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error triggering job ${jobId}: ${error}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Refresh job configuration from state\n\t */\n\tprivate async refreshJobConfig(jobId: string): Promise<void> {\n\t\ttry {\n\t\t\tconst stateObj = await this.adapter.getStateAsync(jobId);\n\t\t\tif (!stateObj || !stateObj.val) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`CronJobManager: No configuration found for job ${jobId} during refresh, keeping existing config`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Parse configuration\n\t\t\tlet config: any;\n\t\t\ttry {\n\t\t\t\tconfig = JSON.parse(stateObj.val as string);\n\t\t\t} catch (parseError) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`CronJobManager: Invalid JSON configuration for job ${jobId} during refresh: ${parseError}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if job needs to be updated\n\t\t\tconst existingJob = this.jobs.get(jobId);\n\t\t\tif (existingJob && JSON.stringify(existingJob.config) !== JSON.stringify(config)) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Config changed during refresh for job ${jobId}, updating job`);\n\t\t\t\t// Remove existing job completely before adding the new one\n\t\t\t\tthis.removeJob(jobId);\n\t\t\t\tawait this.addOrUpdateJob(jobId, config);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error refreshing job config for ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a cron job\n\t */\n\tprivate async executeJob(jobId: string): Promise<void> {\n\t\tconst startTime = new Date().toISOString();\n\n\t\ttry {\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tif (!job) {\n\t\t\t\tthrow new CronJobError(`Job ${jobId} not found`, jobId, CRON_ERROR_CODE.TARGET_NOT_FOUND);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Executing job ${jobId}`);\n\n\t\t\t// Execute all targets\n\t\t\tfor (const target of job.config.targets) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Executing target ${target.id} with value ${target.value}`);\n\t\t\t\tawait this.executeTarget(target);\n\t\t\t}\n\n\t\t\t// Update status\n\t\t\tconst status: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.SUCCESS,\n\t\t\t\tnextRun:\n\t\t\t\t\tjob.config.active && job.config.type === CRON_JOB_TYPE.RECURRING && job.config.cron\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tjob.status = status;\n\t\t\tawait this.updateJobStatus(jobId, status);\n\n\t\t\t// Handle once-type jobs\n\t\t\tif (job.config.type === CRON_JOB_TYPE.ONCE) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: One-time job ${jobId} completed, deactivating`);\n\t\t\t\tjob.config.active = false;\n\t\t\t\tif (job.task) {\n\t\t\t\t\tjob.task.stop();\n\t\t\t\t\tjob.task = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`CronJobManager: Job ${jobId} executed successfully`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error executing job ${jobId}: ${error}`);\n\n\t\t\tconst job = this.jobs.get(jobId);\n\t\t\tconst errorStatus: CronJobStatus = {\n\t\t\t\tlastRun: startTime,\n\t\t\t\tstatus: CRON_JOB_STATUS.ERROR,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\tnextRun:\n\t\t\t\t\tjob?.config.active && job.config.type === CRON_JOB_TYPE.RECURRING && job.config.cron\n\t\t\t\t\t\t? this.getNextRunTime(job.config.cron)\n\t\t\t\t\t\t: undefined,\n\t\t\t};\n\n\t\t\tif (job) {\n\t\t\t\tjob.status = errorStatus;\n\t\t\t}\n\t\t\tawait this.updateJobStatus(jobId, errorStatus);\n\t\t}\n\t}\n\n\t/**\n\t * Execute a single target\n\t */\n\tprivate async executeTarget(target: CronTarget): Promise<void> {\n\t\ttry {\n\t\t\t// Apply delay if specified\n\t\t\tif (target.delay && target.delay > 0) {\n\t\t\t\tthis.adapter.log.debug(`CronJobManager: Delaying execution of ${target.id} by ${target.delay}ms`);\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, target.delay));\n\t\t\t}\n\n\t\t\t// Resolve the target value based on type\n\t\t\tconst resolvedValue = await this.resolveTargetValue(target);\n\n\t\t\t// Set the state with proper acknowledgment\n\t\t\tawait this.adapter.setForeignStateAsync(target.id, {\n\t\t\t\tval: resolvedValue,\n\t\t\t\tack: false,\n\t\t\t});\n\t\t\tthis.adapter.log.debug(\n\t\t\t\t`CronJobManager: Set ${target.id} = ${resolvedValue} (type: ${target.type || CRON_TARGET_TYPE.VALUE})${target.delay ? ` after ${target.delay}ms delay` : \"\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tconst errorMessage = `Error setting ${target.id}: ${error instanceof Error ? error.message : String(error)}`;\n\t\t\tthis.adapter.log.error(`CronJobManager: ${errorMessage}`);\n\t\t\tthrow new CronJobError(\n\t\t\t\terrorMessage,\n\t\t\t\ttarget.id,\n\t\t\t\tCRON_ERROR_CODE.EXECUTION_FAILED,\n\t\t\t\terror instanceof Error ? error : undefined,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve target value based on type\n\t */\n\tprivate async resolveTargetValue(target: CronTarget): Promise<any> {\n\t\tconst targetType = target.type || CRON_TARGET_TYPE.VALUE;\n\n\t\tswitch (targetType) {\n\t\t\tcase CRON_TARGET_TYPE.VALUE:\n\t\t\t\t// Direct value\n\t\t\t\treturn target.value;\n\n\t\t\tcase CRON_TARGET_TYPE.STATE:\n\t\t\t\t// Get value from another state\n\t\t\t\ttry {\n\t\t\t\t\tconst sourceState = await this.adapter.getStateAsync(target.value as string);\n\t\t\t\t\tif (sourceState === null || sourceState === undefined) {\n\t\t\t\t\t\tthis.adapter.log.warn(`CronJobManager: Source state ${target.value} not found, using null`);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn sourceState.val;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.error(`CronJobManager: Error reading source state ${target.value}: ${error}`);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new CronJobError(`Unknown target type: ${targetType}`, target.id, CRON_ERROR_CODE.CONFIG_INVALID);\n\t\t}\n\t}\n\n\t/**\n\t * Update job status\n\t */\n\tprivate async updateJobStatus(jobId: string, status: CronJobStatus): Promise<void> {\n\t\ttry {\n\t\t\tconst statusId = jobId + \".status\";\n\t\t\tawait this.adapter.setForeignStateAsync(statusId, {\n\t\t\t\tval: JSON.stringify(status, null, 2),\n\t\t\t\tack: true,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error updating status for job ${jobId}: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Get next run time for a cron expression\n\t */\n\tprivate getNextRunTime(cronExpression: string): string | undefined {\n\t\ttry {\n\t\t\t// This is a simplified implementation\n\t\t\t// In a real implementation, you'd use a proper cron parser\n\t\t\tconst now = new Date();\n\t\t\tconst nextRun = new Date(now.getTime() + 60000); // Simple: next minute\n\t\t\treturn nextRun.toISOString();\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.warn(`CronJobManager: Error calculating next run time for '${cronExpression}': ${error}`);\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Start periodic cleanup of orphaned objects\n\t */\n\tprivate startPeriodicCleanup(): void {\n\t\t// Run cleanup every 5 minutes\n\t\tthis.cleanupInterval = setInterval(\n\t\t\tasync () => {\n\t\t\t\tawait this.cleanupOrphanedObjects();\n\t\t\t},\n\t\t\t5 * 60 * 1000, // 5 minutes\n\t\t);\n\n\t\tthis.adapter.log.debug(\"CronJobManager: Started periodic cleanup of orphaned objects\");\n\t}\n\n\t/**\n\t * Clean up orphaned status and trigger objects\n\t */\n\tprivate async cleanupOrphanedObjects(): Promise<void> {\n\t\ttry {\n\t\t\tthis.adapter.log.debug(\"CronJobManager: Starting cleanup of orphaned objects\");\n\n\t\t\t// Get all objects in the adapter namespace\n\t\t\tconst objects = await this.adapter.getObjectListAsync({\n\t\t\t\tstartkey: this.adapter.namespace,\n\t\t\t\tendkey: this.adapter.namespace + \"\\u9999\",\n\t\t\t});\n\n\t\t\tconst orphanedObjects: string[] = [];\n\n\t\t\t// Check for orphaned status and trigger objects\n\t\t\tfor (const obj of objects.rows) {\n\t\t\t\tconst objId = obj.id;\n\n\t\t\t\t// Check if this is a status or trigger object\n\t\t\t\tif (objId.endsWith(\".status\") || objId.endsWith(\".trigger\")) {\n\t\t\t\t\t// Extract the job ID by removing the suffix\n\t\t\t\t\tconst jobId = objId.replace(/\\.(status|trigger)$/, \"\");\n\n\t\t\t\t\t// Check if the corresponding job exists\n\t\t\t\t\tif (!this.jobs.has(jobId)) {\n\t\t\t\t\t\t// Check if the job state object exists\n\t\t\t\t\t\tconst jobStateExists = await this.checkJobStateExists(jobId);\n\t\t\t\t\t\tif (!jobStateExists) {\n\t\t\t\t\t\t\torphanedObjects.push(objId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove orphaned objects\n\t\t\tfor (const objId of orphanedObjects) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.adapter.delObjectAsync(objId);\n\t\t\t\t\tthis.adapter.log.info(`CronJobManager: Cleaned up orphaned object ${objId}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.warn(`CronJobManager: Error removing orphaned object ${objId}: ${error}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (orphanedObjects.length > 0) {\n\t\t\t\tthis.adapter.log.info(`CronJobManager: Cleaned up ${orphanedObjects.length} orphaned objects`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`CronJobManager: Error during orphaned objects cleanup: ${error}`);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a job state object exists\n\t */\n\tprivate async checkJobStateExists(jobId: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst state = await this.adapter.getStateAsync(jobId);\n\t\t\treturn state !== null && state !== undefined;\n\t\t} catch (error) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
